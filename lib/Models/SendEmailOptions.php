<?php
/**
 * SendEmailOptions
 *
 * PHP version 5
 *
 * @category Class
 * @package  MailSlurp
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 4.3.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace MailSlurp\Models;

use \ArrayAccess;
use \MailSlurp\ObjectSerializer;

/**
 * SendEmailOptions Class Doc Comment
 *
 * @category Class
 * @description Options for the email to be sent
 * @package  MailSlurp
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class SendEmailOptions implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'SendEmailOptions';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'to_contacts' => 'string[]',
        'to_group' => 'string',
        'to' => 'string[]',
        'from' => 'string',
        'cc' => 'string[]',
        'bcc' => 'string[]',
        'subject' => 'string',
        'reply_to' => 'string',
        'body' => 'string',
        'html' => 'bool',
        'is_html' => 'bool',
        'charset' => 'string',
        'attachments' => 'string[]',
        'template_variables' => 'map[string,object]',
        'template' => 'string',
        'send_strategy' => 'string',
        'use_inbox_name' => 'bool',
        'add_tracking_pixel' => 'bool',
        'filter_bounced_recipients' => 'bool',
        'validate_email_addresses' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPIFormats = [
        'to_contacts' => 'uuid',
        'to_group' => 'uuid',
        'to' => null,
        'from' => null,
        'cc' => null,
        'bcc' => null,
        'subject' => null,
        'reply_to' => null,
        'body' => null,
        'html' => null,
        'is_html' => null,
        'charset' => null,
        'attachments' => null,
        'template_variables' => null,
        'template' => 'uuid',
        'send_strategy' => null,
        'use_inbox_name' => null,
        'add_tracking_pixel' => null,
        'filter_bounced_recipients' => null,
        'validate_email_addresses' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'to_contacts' => 'toContacts',
        'to_group' => 'toGroup',
        'to' => 'to',
        'from' => 'from',
        'cc' => 'cc',
        'bcc' => 'bcc',
        'subject' => 'subject',
        'reply_to' => 'replyTo',
        'body' => 'body',
        'html' => 'html',
        'is_html' => 'isHTML',
        'charset' => 'charset',
        'attachments' => 'attachments',
        'template_variables' => 'templateVariables',
        'template' => 'template',
        'send_strategy' => 'sendStrategy',
        'use_inbox_name' => 'useInboxName',
        'add_tracking_pixel' => 'addTrackingPixel',
        'filter_bounced_recipients' => 'filterBouncedRecipients',
        'validate_email_addresses' => 'validateEmailAddresses'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'to_contacts' => 'setToContacts',
        'to_group' => 'setToGroup',
        'to' => 'setTo',
        'from' => 'setFrom',
        'cc' => 'setCc',
        'bcc' => 'setBcc',
        'subject' => 'setSubject',
        'reply_to' => 'setReplyTo',
        'body' => 'setBody',
        'html' => 'setHtml',
        'is_html' => 'setIsHtml',
        'charset' => 'setCharset',
        'attachments' => 'setAttachments',
        'template_variables' => 'setTemplateVariables',
        'template' => 'setTemplate',
        'send_strategy' => 'setSendStrategy',
        'use_inbox_name' => 'setUseInboxName',
        'add_tracking_pixel' => 'setAddTrackingPixel',
        'filter_bounced_recipients' => 'setFilterBouncedRecipients',
        'validate_email_addresses' => 'setValidateEmailAddresses'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'to_contacts' => 'getToContacts',
        'to_group' => 'getToGroup',
        'to' => 'getTo',
        'from' => 'getFrom',
        'cc' => 'getCc',
        'bcc' => 'getBcc',
        'subject' => 'getSubject',
        'reply_to' => 'getReplyTo',
        'body' => 'getBody',
        'html' => 'getHtml',
        'is_html' => 'getIsHtml',
        'charset' => 'getCharset',
        'attachments' => 'getAttachments',
        'template_variables' => 'getTemplateVariables',
        'template' => 'getTemplate',
        'send_strategy' => 'getSendStrategy',
        'use_inbox_name' => 'getUseInboxName',
        'add_tracking_pixel' => 'getAddTrackingPixel',
        'filter_bounced_recipients' => 'getFilterBouncedRecipients',
        'validate_email_addresses' => 'getValidateEmailAddresses'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    const SEND_STRATEGY_SINGLE_MESSAGE = 'SINGLE_MESSAGE';
    const VALIDATE_EMAIL_ADDRESSES_VALIDATE_FILTER_REMOVE_INVALID = 'VALIDATE_FILTER_REMOVE_INVALID';
    const VALIDATE_EMAIL_ADDRESSES_VALIDATE_ERROR_IF_INVALID = 'VALIDATE_ERROR_IF_INVALID';
    const VALIDATE_EMAIL_ADDRESSES_NO_VALIDATION = 'NO_VALIDATION';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSendStrategyAllowableValues()
    {
        return [
            self::SEND_STRATEGY_SINGLE_MESSAGE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getValidateEmailAddressesAllowableValues()
    {
        return [
            self::VALIDATE_EMAIL_ADDRESSES_VALIDATE_FILTER_REMOVE_INVALID,
            self::VALIDATE_EMAIL_ADDRESSES_VALIDATE_ERROR_IF_INVALID,
            self::VALIDATE_EMAIL_ADDRESSES_NO_VALIDATION,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['to_contacts'] = isset($data['to_contacts']) ? $data['to_contacts'] : null;
        $this->container['to_group'] = isset($data['to_group']) ? $data['to_group'] : null;
        $this->container['to'] = isset($data['to']) ? $data['to'] : null;
        $this->container['from'] = isset($data['from']) ? $data['from'] : null;
        $this->container['cc'] = isset($data['cc']) ? $data['cc'] : null;
        $this->container['bcc'] = isset($data['bcc']) ? $data['bcc'] : null;
        $this->container['subject'] = isset($data['subject']) ? $data['subject'] : null;
        $this->container['reply_to'] = isset($data['reply_to']) ? $data['reply_to'] : null;
        $this->container['body'] = isset($data['body']) ? $data['body'] : null;
        $this->container['html'] = isset($data['html']) ? $data['html'] : null;
        $this->container['is_html'] = isset($data['is_html']) ? $data['is_html'] : null;
        $this->container['charset'] = isset($data['charset']) ? $data['charset'] : null;
        $this->container['attachments'] = isset($data['attachments']) ? $data['attachments'] : null;
        $this->container['template_variables'] = isset($data['template_variables']) ? $data['template_variables'] : null;
        $this->container['template'] = isset($data['template']) ? $data['template'] : null;
        $this->container['send_strategy'] = isset($data['send_strategy']) ? $data['send_strategy'] : null;
        $this->container['use_inbox_name'] = isset($data['use_inbox_name']) ? $data['use_inbox_name'] : null;
        $this->container['add_tracking_pixel'] = isset($data['add_tracking_pixel']) ? $data['add_tracking_pixel'] : null;
        $this->container['filter_bounced_recipients'] = isset($data['filter_bounced_recipients']) ? $data['filter_bounced_recipients'] : null;
        $this->container['validate_email_addresses'] = isset($data['validate_email_addresses']) ? $data['validate_email_addresses'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getSendStrategyAllowableValues();
        if (!is_null($this->container['send_strategy']) && !in_array($this->container['send_strategy'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'send_strategy', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getValidateEmailAddressesAllowableValues();
        if (!is_null($this->container['validate_email_addresses']) && !in_array($this->container['validate_email_addresses'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'validate_email_addresses', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets to_contacts
     *
     * @return string[]|null
     */
    public function getToContacts()
    {
        return $this->container['to_contacts'];
    }

    /**
     * Sets to_contacts
     *
     * @param string[]|null $to_contacts Optional list of contact IDs to send email to. Manage your contacts via the API or dashboard. When contacts are used the email is sent to each contact separately so they will not see other recipients.
     *
     * @return $this
     */
    public function setToContacts($to_contacts)
    {
        $this->container['to_contacts'] = $to_contacts;

        return $this;
    }

    /**
     * Gets to_group
     *
     * @return string|null
     */
    public function getToGroup()
    {
        return $this->container['to_group'];
    }

    /**
     * Sets to_group
     *
     * @param string|null $to_group Optional contact group ID to send email to. You can create contacts and contact groups in the API or dashboard and use them for email campaigns. When contact groups are used the email is sent to each contact separately so they will not see other recipients
     *
     * @return $this
     */
    public function setToGroup($to_group)
    {
        $this->container['to_group'] = $to_group;

        return $this;
    }

    /**
     * Gets to
     *
     * @return string[]|null
     */
    public function getTo()
    {
        return $this->container['to'];
    }

    /**
     * Sets to
     *
     * @param string[]|null $to List of destination email addresses. Each email address must be RFC 5322 format. Even single recipients must be in array form. Maximum recipients per email depends on your plan. If you need to send many emails try using contacts or contact groups or use a non standard sendStrategy to ensure that spam filters are not triggered (many recipients in one email can affect your spam rating). Be cautious when sending emails that your recipients exist. High bounce rates (meaning a high percentage of emails cannot be delivered because an address does not exist) can result in account freezing.
     *
     * @return $this
     */
    public function setTo($to)
    {
        $this->container['to'] = $to;

        return $this;
    }

    /**
     * Gets from
     *
     * @return string|null
     */
    public function getFrom()
    {
        return $this->container['from'];
    }

    /**
     * Sets from
     *
     * @param string|null $from Optional from address. Email address is RFC 5322 format and may include a display name and email in angle brackets (`my@address.com` or `My inbox <my@address.com>`). If no sender is set the source inbox address will be used for this field. If you set `useInboxName` to `true` the from field will include the inbox name as a display name: `inbox_name <inbox@address.com>`. For this to work use the name field when creating an inbox. Beware of potential spam penalties when setting the from field to an address not used by the inbox. Your emails may get blocked by services if you impersonate another address. To use a custom email addresses use a custom domain. You can create domains with the DomainController. The domain must be verified in the dashboard before it can be used.
     *
     * @return $this
     */
    public function setFrom($from)
    {
        $this->container['from'] = $from;

        return $this;
    }

    /**
     * Gets cc
     *
     * @return string[]|null
     */
    public function getCc()
    {
        return $this->container['cc'];
    }

    /**
     * Sets cc
     *
     * @param string[]|null $cc Optional list of cc destination email addresses
     *
     * @return $this
     */
    public function setCc($cc)
    {
        $this->container['cc'] = $cc;

        return $this;
    }

    /**
     * Gets bcc
     *
     * @return string[]|null
     */
    public function getBcc()
    {
        return $this->container['bcc'];
    }

    /**
     * Sets bcc
     *
     * @param string[]|null $bcc Optional list of bcc destination email addresses
     *
     * @return $this
     */
    public function setBcc($bcc)
    {
        $this->container['bcc'] = $bcc;

        return $this;
    }

    /**
     * Gets subject
     *
     * @return string|null
     */
    public function getSubject()
    {
        return $this->container['subject'];
    }

    /**
     * Sets subject
     *
     * @param string|null $subject Optional email subject line
     *
     * @return $this
     */
    public function setSubject($subject)
    {
        $this->container['subject'] = $subject;

        return $this;
    }

    /**
     * Gets reply_to
     *
     * @return string|null
     */
    public function getReplyTo()
    {
        return $this->container['reply_to'];
    }

    /**
     * Sets reply_to
     *
     * @param string|null $reply_to Optional replyTo header
     *
     * @return $this
     */
    public function setReplyTo($reply_to)
    {
        $this->container['reply_to'] = $reply_to;

        return $this;
    }

    /**
     * Gets body
     *
     * @return string|null
     */
    public function getBody()
    {
        return $this->container['body'];
    }

    /**
     * Sets body
     *
     * @param string|null $body Optional contents of email. If body contains HTML then set `isHTML` to true to ensure that email clients render it correctly. You can use moustache template syntax in the email body in conjunction with `toGroup` contact variables or `templateVariables` data. If you need more templating control consider creating a template and using the `template` property instead of the body.
     *
     * @return $this
     */
    public function setBody($body)
    {
        $this->container['body'] = $body;

        return $this;
    }

    /**
     * Gets html
     *
     * @return bool|null
     */
    public function getHtml()
    {
        return $this->container['html'];
    }

    /**
     * Sets html
     *
     * @param bool|null $html Optional HTML flag to indicate that contents is HTML. Set's a `content-type: text/html` for email. (Deprecated: use `isHTML` instead.)
     *
     * @return $this
     */
    public function setHtml($html)
    {
        $this->container['html'] = $html;

        return $this;
    }

    /**
     * Gets is_html
     *
     * @return bool|null
     */
    public function getIsHtml()
    {
        return $this->container['is_html'];
    }

    /**
     * Sets is_html
     *
     * @param bool|null $is_html Optional HTML flag. If true the `content-type` of the email will be `text/html`. Set to true when sending HTML to ensure proper rending on email clients
     *
     * @return $this
     */
    public function setIsHtml($is_html)
    {
        $this->container['is_html'] = $is_html;

        return $this;
    }

    /**
     * Gets charset
     *
     * @return string|null
     */
    public function getCharset()
    {
        return $this->container['charset'];
    }

    /**
     * Sets charset
     *
     * @param string|null $charset Optional charset
     *
     * @return $this
     */
    public function setCharset($charset)
    {
        $this->container['charset'] = $charset;

        return $this;
    }

    /**
     * Gets attachments
     *
     * @return string[]|null
     */
    public function getAttachments()
    {
        return $this->container['attachments'];
    }

    /**
     * Sets attachments
     *
     * @param string[]|null $attachments Optional list of attachment IDs to send with this email. You must first upload each attachment separately via method call or dashboard in order to obtain attachment IDs. This way you can reuse attachments with different emails once uploaded. There are several ways to upload that support `multi-part form`, `base64 file encoding`, and octet stream binary uploads. See the `UploadController` for available methods.
     *
     * @return $this
     */
    public function setAttachments($attachments)
    {
        $this->container['attachments'] = $attachments;

        return $this;
    }

    /**
     * Gets template_variables
     *
     * @return map[string,object]|null
     */
    public function getTemplateVariables()
    {
        return $this->container['template_variables'];
    }

    /**
     * Sets template_variables
     *
     * @param map[string,object]|null $template_variables Optional map of template variables. Will replace moustache syntax variables in subject and body or template with the associated values if found.
     *
     * @return $this
     */
    public function setTemplateVariables($template_variables)
    {
        $this->container['template_variables'] = $template_variables;

        return $this;
    }

    /**
     * Gets template
     *
     * @return string|null
     */
    public function getTemplate()
    {
        return $this->container['template'];
    }

    /**
     * Sets template
     *
     * @param string|null $template Optional template ID to use for body. Will override body if provided. When using a template make sure you pass the corresponding map of `templateVariables`. You can find which variables are needed by fetching the template itself or viewing it in the dashboard.
     *
     * @return $this
     */
    public function setTemplate($template)
    {
        $this->container['template'] = $template;

        return $this;
    }

    /**
     * Gets send_strategy
     *
     * @return string|null
     */
    public function getSendStrategy()
    {
        return $this->container['send_strategy'];
    }

    /**
     * Sets send_strategy
     *
     * @param string|null $send_strategy How an email should be sent based on its recipients
     *
     * @return $this
     */
    public function setSendStrategy($send_strategy)
    {
        $allowedValues = $this->getSendStrategyAllowableValues();
        if (!is_null($send_strategy) && !in_array($send_strategy, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'send_strategy', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['send_strategy'] = $send_strategy;

        return $this;
    }

    /**
     * Gets use_inbox_name
     *
     * @return bool|null
     */
    public function getUseInboxName()
    {
        return $this->container['use_inbox_name'];
    }

    /**
     * Sets use_inbox_name
     *
     * @param bool|null $use_inbox_name Use name of inbox as sender email address name. Will construct RFC 5322 email address with `Inbox name <inbox@address.com>` if the inbox has a name.
     *
     * @return $this
     */
    public function setUseInboxName($use_inbox_name)
    {
        $this->container['use_inbox_name'] = $use_inbox_name;

        return $this;
    }

    /**
     * Gets add_tracking_pixel
     *
     * @return bool|null
     */
    public function getAddTrackingPixel()
    {
        return $this->container['add_tracking_pixel'];
    }

    /**
     * Sets add_tracking_pixel
     *
     * @param bool|null $add_tracking_pixel Add tracking pixel to email
     *
     * @return $this
     */
    public function setAddTrackingPixel($add_tracking_pixel)
    {
        $this->container['add_tracking_pixel'] = $add_tracking_pixel;

        return $this;
    }

    /**
     * Gets filter_bounced_recipients
     *
     * @return bool|null
     */
    public function getFilterBouncedRecipients()
    {
        return $this->container['filter_bounced_recipients'];
    }

    /**
     * Sets filter_bounced_recipients
     *
     * @param bool|null $filter_bounced_recipients Filter recipients to remove any bounced recipients from to, bcc, and cc before sending
     *
     * @return $this
     */
    public function setFilterBouncedRecipients($filter_bounced_recipients)
    {
        $this->container['filter_bounced_recipients'] = $filter_bounced_recipients;

        return $this;
    }

    /**
     * Gets validate_email_addresses
     *
     * @return string|null
     */
    public function getValidateEmailAddresses()
    {
        return $this->container['validate_email_addresses'];
    }

    /**
     * Sets validate_email_addresses
     *
     * @param string|null $validate_email_addresses Validate recipient email addresses before sending
     *
     * @return $this
     */
    public function setValidateEmailAddresses($validate_email_addresses)
    {
        $allowedValues = $this->getValidateEmailAddressesAllowableValues();
        if (!is_null($validate_email_addresses) && !in_array($validate_email_addresses, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'validate_email_addresses', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['validate_email_addresses'] = $validate_email_addresses;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


