<?php
/**
 * SendEmailOptions
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  MailSlurp
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.2.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace MailSlurp\Models;

use \ArrayAccess;
use \MailSlurp\ObjectSerializer;

/**
 * SendEmailOptions Class Doc Comment
 *
 * @category Class
 * @description Options for the email to be sent
 * @package  MailSlurp
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class SendEmailOptions implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'SendEmailOptions';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'to_contacts' => 'string[]',
        'to_group' => 'string',
        'to' => 'string[]',
        'from' => 'string',
        'cc' => 'string[]',
        'bcc' => 'string[]',
        'subject' => 'string',
        'reply_to' => 'string',
        'custom_headers' => 'array<string,string>',
        'body' => 'string',
        'html' => 'bool',
        'is_html' => 'bool',
        'charset' => 'string',
        'attachments' => 'string[]',
        'template_variables' => 'array<string,object>',
        'template' => 'string',
        'send_strategy' => 'string',
        'use_inbox_name' => 'bool',
        'add_tracking_pixel' => 'bool',
        'filter_bounced_recipients' => 'bool',
        'validate_email_addresses' => 'string',
        'ignore_empty_recipients' => 'bool',
        'is_x_amp_html' => 'bool',
        'body_parts' => '\MailSlurp\Models\SendEmailBodyPart[]'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'to_contacts' => 'uuid',
        'to_group' => 'uuid',
        'to' => null,
        'from' => null,
        'cc' => null,
        'bcc' => null,
        'subject' => null,
        'reply_to' => null,
        'custom_headers' => null,
        'body' => null,
        'html' => null,
        'is_html' => null,
        'charset' => null,
        'attachments' => null,
        'template_variables' => null,
        'template' => 'uuid',
        'send_strategy' => null,
        'use_inbox_name' => null,
        'add_tracking_pixel' => null,
        'filter_bounced_recipients' => null,
        'validate_email_addresses' => null,
        'ignore_empty_recipients' => null,
        'is_x_amp_html' => null,
        'body_parts' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'to_contacts' => true,
		'to_group' => true,
		'to' => true,
		'from' => true,
		'cc' => true,
		'bcc' => true,
		'subject' => true,
		'reply_to' => true,
		'custom_headers' => true,
		'body' => true,
		'html' => true,
		'is_html' => true,
		'charset' => true,
		'attachments' => true,
		'template_variables' => true,
		'template' => true,
		'send_strategy' => true,
		'use_inbox_name' => true,
		'add_tracking_pixel' => true,
		'filter_bounced_recipients' => true,
		'validate_email_addresses' => true,
		'ignore_empty_recipients' => true,
		'is_x_amp_html' => true,
		'body_parts' => true
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'to_contacts' => 'toContacts',
        'to_group' => 'toGroup',
        'to' => 'to',
        'from' => 'from',
        'cc' => 'cc',
        'bcc' => 'bcc',
        'subject' => 'subject',
        'reply_to' => 'replyTo',
        'custom_headers' => 'customHeaders',
        'body' => 'body',
        'html' => 'html',
        'is_html' => 'isHTML',
        'charset' => 'charset',
        'attachments' => 'attachments',
        'template_variables' => 'templateVariables',
        'template' => 'template',
        'send_strategy' => 'sendStrategy',
        'use_inbox_name' => 'useInboxName',
        'add_tracking_pixel' => 'addTrackingPixel',
        'filter_bounced_recipients' => 'filterBouncedRecipients',
        'validate_email_addresses' => 'validateEmailAddresses',
        'ignore_empty_recipients' => 'ignoreEmptyRecipients',
        'is_x_amp_html' => 'isXAmpHtml',
        'body_parts' => 'bodyParts'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'to_contacts' => 'setToContacts',
        'to_group' => 'setToGroup',
        'to' => 'setTo',
        'from' => 'setFrom',
        'cc' => 'setCc',
        'bcc' => 'setBcc',
        'subject' => 'setSubject',
        'reply_to' => 'setReplyTo',
        'custom_headers' => 'setCustomHeaders',
        'body' => 'setBody',
        'html' => 'setHtml',
        'is_html' => 'setIsHtml',
        'charset' => 'setCharset',
        'attachments' => 'setAttachments',
        'template_variables' => 'setTemplateVariables',
        'template' => 'setTemplate',
        'send_strategy' => 'setSendStrategy',
        'use_inbox_name' => 'setUseInboxName',
        'add_tracking_pixel' => 'setAddTrackingPixel',
        'filter_bounced_recipients' => 'setFilterBouncedRecipients',
        'validate_email_addresses' => 'setValidateEmailAddresses',
        'ignore_empty_recipients' => 'setIgnoreEmptyRecipients',
        'is_x_amp_html' => 'setIsXAmpHtml',
        'body_parts' => 'setBodyParts'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'to_contacts' => 'getToContacts',
        'to_group' => 'getToGroup',
        'to' => 'getTo',
        'from' => 'getFrom',
        'cc' => 'getCc',
        'bcc' => 'getBcc',
        'subject' => 'getSubject',
        'reply_to' => 'getReplyTo',
        'custom_headers' => 'getCustomHeaders',
        'body' => 'getBody',
        'html' => 'getHtml',
        'is_html' => 'getIsHtml',
        'charset' => 'getCharset',
        'attachments' => 'getAttachments',
        'template_variables' => 'getTemplateVariables',
        'template' => 'getTemplate',
        'send_strategy' => 'getSendStrategy',
        'use_inbox_name' => 'getUseInboxName',
        'add_tracking_pixel' => 'getAddTrackingPixel',
        'filter_bounced_recipients' => 'getFilterBouncedRecipients',
        'validate_email_addresses' => 'getValidateEmailAddresses',
        'ignore_empty_recipients' => 'getIgnoreEmptyRecipients',
        'is_x_amp_html' => 'getIsXAmpHtml',
        'body_parts' => 'getBodyParts'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const SEND_STRATEGY_SINGLE_MESSAGE = 'SINGLE_MESSAGE';
    public const VALIDATE_EMAIL_ADDRESSES_VALIDATE_FILTER_REMOVE_INVALID = 'VALIDATE_FILTER_REMOVE_INVALID';
    public const VALIDATE_EMAIL_ADDRESSES_VALIDATE_ERROR_IF_INVALID = 'VALIDATE_ERROR_IF_INVALID';
    public const VALIDATE_EMAIL_ADDRESSES_NO_VALIDATION = 'NO_VALIDATION';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSendStrategyAllowableValues()
    {
        return [
            self::SEND_STRATEGY_SINGLE_MESSAGE,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getValidateEmailAddressesAllowableValues()
    {
        return [
            self::VALIDATE_EMAIL_ADDRESSES_VALIDATE_FILTER_REMOVE_INVALID,
            self::VALIDATE_EMAIL_ADDRESSES_VALIDATE_ERROR_IF_INVALID,
            self::VALIDATE_EMAIL_ADDRESSES_NO_VALIDATION,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->setIfExists('to_contacts', $data ?? [], null);
        $this->setIfExists('to_group', $data ?? [], null);
        $this->setIfExists('to', $data ?? [], null);
        $this->setIfExists('from', $data ?? [], null);
        $this->setIfExists('cc', $data ?? [], null);
        $this->setIfExists('bcc', $data ?? [], null);
        $this->setIfExists('subject', $data ?? [], null);
        $this->setIfExists('reply_to', $data ?? [], null);
        $this->setIfExists('custom_headers', $data ?? [], null);
        $this->setIfExists('body', $data ?? [], null);
        $this->setIfExists('html', $data ?? [], null);
        $this->setIfExists('is_html', $data ?? [], null);
        $this->setIfExists('charset', $data ?? [], null);
        $this->setIfExists('attachments', $data ?? [], null);
        $this->setIfExists('template_variables', $data ?? [], null);
        $this->setIfExists('template', $data ?? [], null);
        $this->setIfExists('send_strategy', $data ?? [], null);
        $this->setIfExists('use_inbox_name', $data ?? [], null);
        $this->setIfExists('add_tracking_pixel', $data ?? [], null);
        $this->setIfExists('filter_bounced_recipients', $data ?? [], null);
        $this->setIfExists('validate_email_addresses', $data ?? [], null);
        $this->setIfExists('ignore_empty_recipients', $data ?? [], null);
        $this->setIfExists('is_x_amp_html', $data ?? [], null);
        $this->setIfExists('body_parts', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getSendStrategyAllowableValues();
        if (!is_null($this->container['send_strategy']) && !in_array($this->container['send_strategy'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'send_strategy', must be one of '%s'",
                $this->container['send_strategy'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getValidateEmailAddressesAllowableValues();
        if (!is_null($this->container['validate_email_addresses']) && !in_array($this->container['validate_email_addresses'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'validate_email_addresses', must be one of '%s'",
                $this->container['validate_email_addresses'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets to_contacts
     *
     * @return string[]|null
     */
    public function getToContacts()
    {
        return $this->container['to_contacts'];
    }

    /**
     * Sets to_contacts
     *
     * @param string[]|null $to_contacts Optional list of contact IDs to send email to. Manage your contacts via the API or dashboard. When contacts are used the email is sent to each contact separately so they will not see other recipients.
     *
     * @return self
     */
    public function setToContacts($to_contacts)
    {

        if (is_null($to_contacts)) {
            array_push($this->openAPINullablesSetToNull, 'to_contacts');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('to_contacts', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['to_contacts'] = $to_contacts;

        return $this;
    }

    /**
     * Gets to_group
     *
     * @return string|null
     */
    public function getToGroup()
    {
        return $this->container['to_group'];
    }

    /**
     * Sets to_group
     *
     * @param string|null $to_group Optional contact group ID to send email to. You can create contacts and contact groups in the API or dashboard and use them for email campaigns. When contact groups are used the email is sent to each contact separately so they will not see other recipients
     *
     * @return self
     */
    public function setToGroup($to_group)
    {

        if (is_null($to_group)) {
            array_push($this->openAPINullablesSetToNull, 'to_group');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('to_group', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['to_group'] = $to_group;

        return $this;
    }

    /**
     * Gets to
     *
     * @return string[]|null
     */
    public function getTo()
    {
        return $this->container['to'];
    }

    /**
     * Sets to
     *
     * @param string[]|null $to List of destination email addresses. Each email address must be RFC 5322 format. Even single recipients must be in array form. Maximum recipients per email depends on your plan. If you need to send many emails try using contacts or contact groups or use a non standard sendStrategy to ensure that spam filters are not triggered (many recipients in one email can affect your spam rating). Be cautious when sending emails that your recipients exist. High bounce rates (meaning a high percentage of emails cannot be delivered because an address does not exist) can result in account freezing.
     *
     * @return self
     */
    public function setTo($to)
    {

        if (is_null($to)) {
            array_push($this->openAPINullablesSetToNull, 'to');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('to', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['to'] = $to;

        return $this;
    }

    /**
     * Gets from
     *
     * @return string|null
     */
    public function getFrom()
    {
        return $this->container['from'];
    }

    /**
     * Sets from
     *
     * @param string|null $from Optional from address. Email address is RFC 5322 format and may include a display name and email in angle brackets (`my@address.com` or `My inbox <my@address.com>`). If no sender is set the source inbox address will be used for this field. If you set `useInboxName` to `true` the from field will include the inbox name as a display name: `inbox_name <inbox@address.com>`. For this to work use the name field when creating an inbox. Beware of potential spam penalties when setting the from field to an address not used by the inbox. Your emails may get blocked by services if you impersonate another address. To use a custom email addresses use a custom domain. You can create domains with the DomainController. The domain must be verified in the dashboard before it can be used.
     *
     * @return self
     */
    public function setFrom($from)
    {

        if (is_null($from)) {
            array_push($this->openAPINullablesSetToNull, 'from');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('from', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['from'] = $from;

        return $this;
    }

    /**
     * Gets cc
     *
     * @return string[]|null
     */
    public function getCc()
    {
        return $this->container['cc'];
    }

    /**
     * Sets cc
     *
     * @param string[]|null $cc Optional list of cc destination email addresses
     *
     * @return self
     */
    public function setCc($cc)
    {

        if (is_null($cc)) {
            array_push($this->openAPINullablesSetToNull, 'cc');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('cc', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['cc'] = $cc;

        return $this;
    }

    /**
     * Gets bcc
     *
     * @return string[]|null
     */
    public function getBcc()
    {
        return $this->container['bcc'];
    }

    /**
     * Sets bcc
     *
     * @param string[]|null $bcc Optional list of bcc destination email addresses
     *
     * @return self
     */
    public function setBcc($bcc)
    {

        if (is_null($bcc)) {
            array_push($this->openAPINullablesSetToNull, 'bcc');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('bcc', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['bcc'] = $bcc;

        return $this;
    }

    /**
     * Gets subject
     *
     * @return string|null
     */
    public function getSubject()
    {
        return $this->container['subject'];
    }

    /**
     * Sets subject
     *
     * @param string|null $subject Optional email subject line
     *
     * @return self
     */
    public function setSubject($subject)
    {

        if (is_null($subject)) {
            array_push($this->openAPINullablesSetToNull, 'subject');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('subject', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['subject'] = $subject;

        return $this;
    }

    /**
     * Gets reply_to
     *
     * @return string|null
     */
    public function getReplyTo()
    {
        return $this->container['reply_to'];
    }

    /**
     * Sets reply_to
     *
     * @param string|null $reply_to Optional replyTo header
     *
     * @return self
     */
    public function setReplyTo($reply_to)
    {

        if (is_null($reply_to)) {
            array_push($this->openAPINullablesSetToNull, 'reply_to');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('reply_to', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['reply_to'] = $reply_to;

        return $this;
    }

    /**
     * Gets custom_headers
     *
     * @return array<string,string>|null
     */
    public function getCustomHeaders()
    {
        return $this->container['custom_headers'];
    }

    /**
     * Sets custom_headers
     *
     * @param array<string,string>|null $custom_headers Optional custom headers
     *
     * @return self
     */
    public function setCustomHeaders($custom_headers)
    {

        if (is_null($custom_headers)) {
            array_push($this->openAPINullablesSetToNull, 'custom_headers');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('custom_headers', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['custom_headers'] = $custom_headers;

        return $this;
    }

    /**
     * Gets body
     *
     * @return string|null
     */
    public function getBody()
    {
        return $this->container['body'];
    }

    /**
     * Sets body
     *
     * @param string|null $body Optional contents of email. If body contains HTML then set `isHTML` to true to ensure that email clients render it correctly. You can use moustache template syntax in the email body in conjunction with `toGroup` contact variables or `templateVariables` data. If you need more templating control consider creating a template and using the `template` property instead of the body.
     *
     * @return self
     */
    public function setBody($body)
    {

        if (is_null($body)) {
            array_push($this->openAPINullablesSetToNull, 'body');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('body', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['body'] = $body;

        return $this;
    }

    /**
     * Gets html
     *
     * @return bool|null
     */
    public function getHtml()
    {
        return $this->container['html'];
    }

    /**
     * Sets html
     *
     * @param bool|null $html Optional HTML flag to indicate that contents is HTML. Set's a `content-type: text/html` for email. (Deprecated: use `isHTML` instead.)
     *
     * @return self
     */
    public function setHtml($html)
    {

        if (is_null($html)) {
            array_push($this->openAPINullablesSetToNull, 'html');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('html', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['html'] = $html;

        return $this;
    }

    /**
     * Gets is_html
     *
     * @return bool|null
     */
    public function getIsHtml()
    {
        return $this->container['is_html'];
    }

    /**
     * Sets is_html
     *
     * @param bool|null $is_html Optional HTML flag. If true the `content-type` of the email will be `text/html`. Set to true when sending HTML to ensure proper rending on email clients
     *
     * @return self
     */
    public function setIsHtml($is_html)
    {

        if (is_null($is_html)) {
            array_push($this->openAPINullablesSetToNull, 'is_html');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('is_html', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['is_html'] = $is_html;

        return $this;
    }

    /**
     * Gets charset
     *
     * @return string|null
     */
    public function getCharset()
    {
        return $this->container['charset'];
    }

    /**
     * Sets charset
     *
     * @param string|null $charset Optional charset
     *
     * @return self
     */
    public function setCharset($charset)
    {

        if (is_null($charset)) {
            array_push($this->openAPINullablesSetToNull, 'charset');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('charset', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['charset'] = $charset;

        return $this;
    }

    /**
     * Gets attachments
     *
     * @return string[]|null
     */
    public function getAttachments()
    {
        return $this->container['attachments'];
    }

    /**
     * Sets attachments
     *
     * @param string[]|null $attachments Optional list of attachment IDs to send with this email. You must first upload each attachment separately via method call or dashboard in order to obtain attachment IDs. This way you can reuse attachments with different emails once uploaded. There are several ways to upload that support `multi-part form`, `base64 file encoding`, and octet stream binary uploads. See the `UploadController` for available methods.
     *
     * @return self
     */
    public function setAttachments($attachments)
    {

        if (is_null($attachments)) {
            array_push($this->openAPINullablesSetToNull, 'attachments');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('attachments', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['attachments'] = $attachments;

        return $this;
    }

    /**
     * Gets template_variables
     *
     * @return array<string,object>|null
     */
    public function getTemplateVariables()
    {
        return $this->container['template_variables'];
    }

    /**
     * Sets template_variables
     *
     * @param array<string,object>|null $template_variables Optional map of template variables. Will replace moustache syntax variables in subject and body or template with the associated values if found.
     *
     * @return self
     */
    public function setTemplateVariables($template_variables)
    {

        if (is_null($template_variables)) {
            array_push($this->openAPINullablesSetToNull, 'template_variables');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('template_variables', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['template_variables'] = $template_variables;

        return $this;
    }

    /**
     * Gets template
     *
     * @return string|null
     */
    public function getTemplate()
    {
        return $this->container['template'];
    }

    /**
     * Sets template
     *
     * @param string|null $template Optional template ID to use for body. Will override body if provided. When using a template make sure you pass the corresponding map of `templateVariables`. You can find which variables are needed by fetching the template itself or viewing it in the dashboard.
     *
     * @return self
     */
    public function setTemplate($template)
    {

        if (is_null($template)) {
            array_push($this->openAPINullablesSetToNull, 'template');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('template', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['template'] = $template;

        return $this;
    }

    /**
     * Gets send_strategy
     *
     * @return string|null
     */
    public function getSendStrategy()
    {
        return $this->container['send_strategy'];
    }

    /**
     * Sets send_strategy
     *
     * @param string|null $send_strategy How an email should be sent based on its recipients
     *
     * @return self
     */
    public function setSendStrategy($send_strategy)
    {
        $allowedValues = $this->getSendStrategyAllowableValues();
        if (!is_null($send_strategy) && !in_array($send_strategy, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'send_strategy', must be one of '%s'",
                    $send_strategy,
                    implode("', '", $allowedValues)
                )
            );
        }

        if (is_null($send_strategy)) {
            array_push($this->openAPINullablesSetToNull, 'send_strategy');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('send_strategy', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['send_strategy'] = $send_strategy;

        return $this;
    }

    /**
     * Gets use_inbox_name
     *
     * @return bool|null
     */
    public function getUseInboxName()
    {
        return $this->container['use_inbox_name'];
    }

    /**
     * Sets use_inbox_name
     *
     * @param bool|null $use_inbox_name Use name of inbox as sender email address name. Will construct RFC 5322 email address with `Inbox name <inbox@address.com>` if the inbox has a name.
     *
     * @return self
     */
    public function setUseInboxName($use_inbox_name)
    {

        if (is_null($use_inbox_name)) {
            array_push($this->openAPINullablesSetToNull, 'use_inbox_name');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('use_inbox_name', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['use_inbox_name'] = $use_inbox_name;

        return $this;
    }

    /**
     * Gets add_tracking_pixel
     *
     * @return bool|null
     */
    public function getAddTrackingPixel()
    {
        return $this->container['add_tracking_pixel'];
    }

    /**
     * Sets add_tracking_pixel
     *
     * @param bool|null $add_tracking_pixel Add tracking pixel to email
     *
     * @return self
     */
    public function setAddTrackingPixel($add_tracking_pixel)
    {

        if (is_null($add_tracking_pixel)) {
            array_push($this->openAPINullablesSetToNull, 'add_tracking_pixel');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('add_tracking_pixel', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['add_tracking_pixel'] = $add_tracking_pixel;

        return $this;
    }

    /**
     * Gets filter_bounced_recipients
     *
     * @return bool|null
     */
    public function getFilterBouncedRecipients()
    {
        return $this->container['filter_bounced_recipients'];
    }

    /**
     * Sets filter_bounced_recipients
     *
     * @param bool|null $filter_bounced_recipients Filter recipients to remove any bounced recipients from to, bcc, and cc before sending
     *
     * @return self
     */
    public function setFilterBouncedRecipients($filter_bounced_recipients)
    {

        if (is_null($filter_bounced_recipients)) {
            array_push($this->openAPINullablesSetToNull, 'filter_bounced_recipients');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('filter_bounced_recipients', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['filter_bounced_recipients'] = $filter_bounced_recipients;

        return $this;
    }

    /**
     * Gets validate_email_addresses
     *
     * @return string|null
     */
    public function getValidateEmailAddresses()
    {
        return $this->container['validate_email_addresses'];
    }

    /**
     * Sets validate_email_addresses
     *
     * @param string|null $validate_email_addresses Validate recipient email addresses before sending
     *
     * @return self
     */
    public function setValidateEmailAddresses($validate_email_addresses)
    {
        $allowedValues = $this->getValidateEmailAddressesAllowableValues();
        if (!is_null($validate_email_addresses) && !in_array($validate_email_addresses, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'validate_email_addresses', must be one of '%s'",
                    $validate_email_addresses,
                    implode("', '", $allowedValues)
                )
            );
        }

        if (is_null($validate_email_addresses)) {
            array_push($this->openAPINullablesSetToNull, 'validate_email_addresses');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('validate_email_addresses', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['validate_email_addresses'] = $validate_email_addresses;

        return $this;
    }

    /**
     * Gets ignore_empty_recipients
     *
     * @return bool|null
     */
    public function getIgnoreEmptyRecipients()
    {
        return $this->container['ignore_empty_recipients'];
    }

    /**
     * Sets ignore_empty_recipients
     *
     * @param bool|null $ignore_empty_recipients Ignore empty recipients after validation removes all recipients as invalid and fail silently
     *
     * @return self
     */
    public function setIgnoreEmptyRecipients($ignore_empty_recipients)
    {

        if (is_null($ignore_empty_recipients)) {
            array_push($this->openAPINullablesSetToNull, 'ignore_empty_recipients');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('ignore_empty_recipients', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['ignore_empty_recipients'] = $ignore_empty_recipients;

        return $this;
    }

    /**
     * Gets is_x_amp_html
     *
     * @return bool|null
     */
    public function getIsXAmpHtml()
    {
        return $this->container['is_x_amp_html'];
    }

    /**
     * Sets is_x_amp_html
     *
     * @param bool|null $is_x_amp_html Is content AMP4EMAIL compatible. If set will send as x-amp-html part.
     *
     * @return self
     */
    public function setIsXAmpHtml($is_x_amp_html)
    {

        if (is_null($is_x_amp_html)) {
            array_push($this->openAPINullablesSetToNull, 'is_x_amp_html');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('is_x_amp_html', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['is_x_amp_html'] = $is_x_amp_html;

        return $this;
    }

    /**
     * Gets body_parts
     *
     * @return \MailSlurp\Models\SendEmailBodyPart[]|null
     */
    public function getBodyParts()
    {
        return $this->container['body_parts'];
    }

    /**
     * Sets body_parts
     *
     * @param \MailSlurp\Models\SendEmailBodyPart[]|null $body_parts Email body content parts for multipart mime message. Will override body.
     *
     * @return self
     */
    public function setBodyParts($body_parts)
    {

        if (is_null($body_parts)) {
            array_push($this->openAPINullablesSetToNull, 'body_parts');
        } else {
            $nullablesSetToNull = $this->getOpenAPINullablesSetToNull();
            $index = array_search('body_parts', $nullablesSetToNull);
            if ($index !== FALSE) {
                unset($nullablesSetToNull[$index]);
                $this->setOpenAPINullablesSetToNull($nullablesSetToNull);
            }
        }

        $this->container['body_parts'] = $body_parts;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


