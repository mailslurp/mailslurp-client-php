<?php
/**
 * ConnectorControllerApi
 * PHP version 7.4
 *
 * @category Class
 * @package  MailSlurp
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails and SMS from dynamically allocated email addresses and phone numbers. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.2.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace MailSlurp\Apis;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use MailSlurp\ApiException;
use MailSlurp\Configuration;
use MailSlurp\HeaderSelector;
use MailSlurp\ObjectSerializer;

/**
 * ConnectorControllerApi Class Doc Comment
 *
 * @category Class
 * @package  MailSlurp
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ConnectorControllerApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'createConnector' => [
            'application/json',
        ],
        'createConnectorImapConnection' => [
            'application/json',
        ],
        'createConnectorSmtpConnection' => [
            'application/json',
        ],
        'createConnectorSyncSettings' => [
            'application/json',
        ],
        'createConnectorWithOptions' => [
            'application/json',
        ],
        'deleteAllConnector' => [
            'application/json',
        ],
        'deleteConnector' => [
            'application/json',
        ],
        'deleteConnectorImapConnection' => [
            'application/json',
        ],
        'deleteConnectorSmtpConnection' => [
            'application/json',
        ],
        'deleteConnectorSyncSettings' => [
            'application/json',
        ],
        'getAllConnectorEvents' => [
            'application/json',
        ],
        'getConnector' => [
            'application/json',
        ],
        'getConnectorByEmailAddress' => [
            'application/json',
        ],
        'getConnectorByInboxId' => [
            'application/json',
        ],
        'getConnectorByName' => [
            'application/json',
        ],
        'getConnectorEvent' => [
            'application/json',
        ],
        'getConnectorEvents' => [
            'application/json',
        ],
        'getConnectorImapConnection' => [
            'application/json',
        ],
        'getConnectorProviderSettings' => [
            'application/json',
        ],
        'getConnectorSmtpConnection' => [
            'application/json',
        ],
        'getConnectorSyncSettings' => [
            'application/json',
        ],
        'getConnectors' => [
            'application/json',
        ],
        'sendEmailFromConnector' => [
            'application/json',
        ],
        'syncConnector' => [
            'application/json',
        ],
        'testConnectorImapConnection' => [
            'application/json',
        ],
        'testConnectorImapConnectionOptions' => [
            'application/json',
        ],
        'testConnectorSmtpConnection' => [
            'application/json',
        ],
        'testConnectorSmtpConnectionOptions' => [
            'application/json',
        ],
        'updateConnector' => [
            'application/json',
        ],
        'updateConnectorImapConnection' => [
            'application/json',
        ],
        'updateConnectorSmtpConnection' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createConnector
     *
     * Create an inbox connector
     *
     * @param  \MailSlurp\Models\CreateConnectorOptions $create_connector_options create_connector_options (required)
     * @param  string $inbox_id Optional inbox ID to associate with the connector (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnector'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\ConnectorDto
     */
    public function createConnector($create_connector_options, $inbox_id = null, string $contentType = self::contentTypes['createConnector'][0])
    {
        list($response) = $this->createConnectorWithHttpInfo($create_connector_options, $inbox_id, $contentType);
        return $response;
    }

    /**
     * Operation createConnectorWithHttpInfo
     *
     * Create an inbox connector
     *
     * @param  \MailSlurp\Models\CreateConnectorOptions $create_connector_options (required)
     * @param  string $inbox_id Optional inbox ID to associate with the connector (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnector'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\ConnectorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function createConnectorWithHttpInfo($create_connector_options, $inbox_id = null, string $contentType = self::contentTypes['createConnector'][0])
    {
        $request = $this->createConnectorRequest($create_connector_options, $inbox_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\MailSlurp\Models\ConnectorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\ConnectorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\ConnectorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\ConnectorDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\ConnectorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createConnectorAsync
     *
     * Create an inbox connector
     *
     * @param  \MailSlurp\Models\CreateConnectorOptions $create_connector_options (required)
     * @param  string $inbox_id Optional inbox ID to associate with the connector (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConnectorAsync($create_connector_options, $inbox_id = null, string $contentType = self::contentTypes['createConnector'][0])
    {
        return $this->createConnectorAsyncWithHttpInfo($create_connector_options, $inbox_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createConnectorAsyncWithHttpInfo
     *
     * Create an inbox connector
     *
     * @param  \MailSlurp\Models\CreateConnectorOptions $create_connector_options (required)
     * @param  string $inbox_id Optional inbox ID to associate with the connector (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConnectorAsyncWithHttpInfo($create_connector_options, $inbox_id = null, string $contentType = self::contentTypes['createConnector'][0])
    {
        $returnType = '\MailSlurp\Models\ConnectorDto';
        $request = $this->createConnectorRequest($create_connector_options, $inbox_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createConnector'
     *
     * @param  \MailSlurp\Models\CreateConnectorOptions $create_connector_options (required)
     * @param  string $inbox_id Optional inbox ID to associate with the connector (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createConnectorRequest($create_connector_options, $inbox_id = null, string $contentType = self::contentTypes['createConnector'][0])
    {

        // verify the required parameter 'create_connector_options' is set
        if ($create_connector_options === null || (is_array($create_connector_options) && count($create_connector_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_connector_options when calling createConnector'
            );
        }



        $resourcePath = '/connectors';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $inbox_id,
            'inboxId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_connector_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($create_connector_options));
            } else {
                $httpBody = $create_connector_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createConnectorImapConnection
     *
     * Create an inbox connector IMAP connection
     *
     * @param  string $id id (required)
     * @param  \MailSlurp\Models\CreateConnectorImapConnectionOptions $create_connector_imap_connection_options create_connector_imap_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnectorImapConnection'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\ConnectorImapConnectionDto
     */
    public function createConnectorImapConnection($id, $create_connector_imap_connection_options, string $contentType = self::contentTypes['createConnectorImapConnection'][0])
    {
        list($response) = $this->createConnectorImapConnectionWithHttpInfo($id, $create_connector_imap_connection_options, $contentType);
        return $response;
    }

    /**
     * Operation createConnectorImapConnectionWithHttpInfo
     *
     * Create an inbox connector IMAP connection
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorImapConnectionOptions $create_connector_imap_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnectorImapConnection'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\ConnectorImapConnectionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function createConnectorImapConnectionWithHttpInfo($id, $create_connector_imap_connection_options, string $contentType = self::contentTypes['createConnectorImapConnection'][0])
    {
        $request = $this->createConnectorImapConnectionRequest($id, $create_connector_imap_connection_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\MailSlurp\Models\ConnectorImapConnectionDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\ConnectorImapConnectionDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\ConnectorImapConnectionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\ConnectorImapConnectionDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\ConnectorImapConnectionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createConnectorImapConnectionAsync
     *
     * Create an inbox connector IMAP connection
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorImapConnectionOptions $create_connector_imap_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnectorImapConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConnectorImapConnectionAsync($id, $create_connector_imap_connection_options, string $contentType = self::contentTypes['createConnectorImapConnection'][0])
    {
        return $this->createConnectorImapConnectionAsyncWithHttpInfo($id, $create_connector_imap_connection_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createConnectorImapConnectionAsyncWithHttpInfo
     *
     * Create an inbox connector IMAP connection
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorImapConnectionOptions $create_connector_imap_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnectorImapConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConnectorImapConnectionAsyncWithHttpInfo($id, $create_connector_imap_connection_options, string $contentType = self::contentTypes['createConnectorImapConnection'][0])
    {
        $returnType = '\MailSlurp\Models\ConnectorImapConnectionDto';
        $request = $this->createConnectorImapConnectionRequest($id, $create_connector_imap_connection_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createConnectorImapConnection'
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorImapConnectionOptions $create_connector_imap_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnectorImapConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createConnectorImapConnectionRequest($id, $create_connector_imap_connection_options, string $contentType = self::contentTypes['createConnectorImapConnection'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling createConnectorImapConnection'
            );
        }

        // verify the required parameter 'create_connector_imap_connection_options' is set
        if ($create_connector_imap_connection_options === null || (is_array($create_connector_imap_connection_options) && count($create_connector_imap_connection_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_connector_imap_connection_options when calling createConnectorImapConnection'
            );
        }


        $resourcePath = '/connectors/{id}/imap';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_connector_imap_connection_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($create_connector_imap_connection_options));
            } else {
                $httpBody = $create_connector_imap_connection_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createConnectorSmtpConnection
     *
     * Create an inbox connector SMTP connection
     *
     * @param  string $id id (required)
     * @param  \MailSlurp\Models\CreateConnectorSmtpConnectionOptions $create_connector_smtp_connection_options create_connector_smtp_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnectorSmtpConnection'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\ConnectorSmtpConnectionDto
     */
    public function createConnectorSmtpConnection($id, $create_connector_smtp_connection_options, string $contentType = self::contentTypes['createConnectorSmtpConnection'][0])
    {
        list($response) = $this->createConnectorSmtpConnectionWithHttpInfo($id, $create_connector_smtp_connection_options, $contentType);
        return $response;
    }

    /**
     * Operation createConnectorSmtpConnectionWithHttpInfo
     *
     * Create an inbox connector SMTP connection
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorSmtpConnectionOptions $create_connector_smtp_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnectorSmtpConnection'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\ConnectorSmtpConnectionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function createConnectorSmtpConnectionWithHttpInfo($id, $create_connector_smtp_connection_options, string $contentType = self::contentTypes['createConnectorSmtpConnection'][0])
    {
        $request = $this->createConnectorSmtpConnectionRequest($id, $create_connector_smtp_connection_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\MailSlurp\Models\ConnectorSmtpConnectionDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\ConnectorSmtpConnectionDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\ConnectorSmtpConnectionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\ConnectorSmtpConnectionDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\ConnectorSmtpConnectionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createConnectorSmtpConnectionAsync
     *
     * Create an inbox connector SMTP connection
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorSmtpConnectionOptions $create_connector_smtp_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnectorSmtpConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConnectorSmtpConnectionAsync($id, $create_connector_smtp_connection_options, string $contentType = self::contentTypes['createConnectorSmtpConnection'][0])
    {
        return $this->createConnectorSmtpConnectionAsyncWithHttpInfo($id, $create_connector_smtp_connection_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createConnectorSmtpConnectionAsyncWithHttpInfo
     *
     * Create an inbox connector SMTP connection
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorSmtpConnectionOptions $create_connector_smtp_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnectorSmtpConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConnectorSmtpConnectionAsyncWithHttpInfo($id, $create_connector_smtp_connection_options, string $contentType = self::contentTypes['createConnectorSmtpConnection'][0])
    {
        $returnType = '\MailSlurp\Models\ConnectorSmtpConnectionDto';
        $request = $this->createConnectorSmtpConnectionRequest($id, $create_connector_smtp_connection_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createConnectorSmtpConnection'
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorSmtpConnectionOptions $create_connector_smtp_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnectorSmtpConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createConnectorSmtpConnectionRequest($id, $create_connector_smtp_connection_options, string $contentType = self::contentTypes['createConnectorSmtpConnection'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling createConnectorSmtpConnection'
            );
        }

        // verify the required parameter 'create_connector_smtp_connection_options' is set
        if ($create_connector_smtp_connection_options === null || (is_array($create_connector_smtp_connection_options) && count($create_connector_smtp_connection_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_connector_smtp_connection_options when calling createConnectorSmtpConnection'
            );
        }


        $resourcePath = '/connectors/{id}/smtp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_connector_smtp_connection_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($create_connector_smtp_connection_options));
            } else {
                $httpBody = $create_connector_smtp_connection_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createConnectorSyncSettings
     *
     * Create an inbox connector sync settings
     *
     * @param  string $id id (required)
     * @param  \MailSlurp\Models\CreateConnectorSyncSettingsOptions $create_connector_sync_settings_options create_connector_sync_settings_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnectorSyncSettings'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\ConnectorSyncSettingsDto
     */
    public function createConnectorSyncSettings($id, $create_connector_sync_settings_options, string $contentType = self::contentTypes['createConnectorSyncSettings'][0])
    {
        list($response) = $this->createConnectorSyncSettingsWithHttpInfo($id, $create_connector_sync_settings_options, $contentType);
        return $response;
    }

    /**
     * Operation createConnectorSyncSettingsWithHttpInfo
     *
     * Create an inbox connector sync settings
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorSyncSettingsOptions $create_connector_sync_settings_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnectorSyncSettings'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\ConnectorSyncSettingsDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function createConnectorSyncSettingsWithHttpInfo($id, $create_connector_sync_settings_options, string $contentType = self::contentTypes['createConnectorSyncSettings'][0])
    {
        $request = $this->createConnectorSyncSettingsRequest($id, $create_connector_sync_settings_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\MailSlurp\Models\ConnectorSyncSettingsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\ConnectorSyncSettingsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\ConnectorSyncSettingsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\ConnectorSyncSettingsDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\ConnectorSyncSettingsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createConnectorSyncSettingsAsync
     *
     * Create an inbox connector sync settings
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorSyncSettingsOptions $create_connector_sync_settings_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnectorSyncSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConnectorSyncSettingsAsync($id, $create_connector_sync_settings_options, string $contentType = self::contentTypes['createConnectorSyncSettings'][0])
    {
        return $this->createConnectorSyncSettingsAsyncWithHttpInfo($id, $create_connector_sync_settings_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createConnectorSyncSettingsAsyncWithHttpInfo
     *
     * Create an inbox connector sync settings
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorSyncSettingsOptions $create_connector_sync_settings_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnectorSyncSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConnectorSyncSettingsAsyncWithHttpInfo($id, $create_connector_sync_settings_options, string $contentType = self::contentTypes['createConnectorSyncSettings'][0])
    {
        $returnType = '\MailSlurp\Models\ConnectorSyncSettingsDto';
        $request = $this->createConnectorSyncSettingsRequest($id, $create_connector_sync_settings_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createConnectorSyncSettings'
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorSyncSettingsOptions $create_connector_sync_settings_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnectorSyncSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createConnectorSyncSettingsRequest($id, $create_connector_sync_settings_options, string $contentType = self::contentTypes['createConnectorSyncSettings'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling createConnectorSyncSettings'
            );
        }

        // verify the required parameter 'create_connector_sync_settings_options' is set
        if ($create_connector_sync_settings_options === null || (is_array($create_connector_sync_settings_options) && count($create_connector_sync_settings_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_connector_sync_settings_options when calling createConnectorSyncSettings'
            );
        }


        $resourcePath = '/connectors/{id}/sync-settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_connector_sync_settings_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($create_connector_sync_settings_options));
            } else {
                $httpBody = $create_connector_sync_settings_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createConnectorWithOptions
     *
     * Create an inbox connector with options
     *
     * @param  \MailSlurp\Models\CreateConnectorWithOptions $create_connector_with_options create_connector_with_options (required)
     * @param  string $inbox_id Optional inbox ID to associate with the connector (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnectorWithOptions'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\ConnectorDto
     */
    public function createConnectorWithOptions($create_connector_with_options, $inbox_id = null, string $contentType = self::contentTypes['createConnectorWithOptions'][0])
    {
        list($response) = $this->createConnectorWithOptionsWithHttpInfo($create_connector_with_options, $inbox_id, $contentType);
        return $response;
    }

    /**
     * Operation createConnectorWithOptionsWithHttpInfo
     *
     * Create an inbox connector with options
     *
     * @param  \MailSlurp\Models\CreateConnectorWithOptions $create_connector_with_options (required)
     * @param  string $inbox_id Optional inbox ID to associate with the connector (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnectorWithOptions'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\ConnectorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function createConnectorWithOptionsWithHttpInfo($create_connector_with_options, $inbox_id = null, string $contentType = self::contentTypes['createConnectorWithOptions'][0])
    {
        $request = $this->createConnectorWithOptionsRequest($create_connector_with_options, $inbox_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\MailSlurp\Models\ConnectorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\ConnectorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\ConnectorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\ConnectorDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\ConnectorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createConnectorWithOptionsAsync
     *
     * Create an inbox connector with options
     *
     * @param  \MailSlurp\Models\CreateConnectorWithOptions $create_connector_with_options (required)
     * @param  string $inbox_id Optional inbox ID to associate with the connector (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnectorWithOptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConnectorWithOptionsAsync($create_connector_with_options, $inbox_id = null, string $contentType = self::contentTypes['createConnectorWithOptions'][0])
    {
        return $this->createConnectorWithOptionsAsyncWithHttpInfo($create_connector_with_options, $inbox_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createConnectorWithOptionsAsyncWithHttpInfo
     *
     * Create an inbox connector with options
     *
     * @param  \MailSlurp\Models\CreateConnectorWithOptions $create_connector_with_options (required)
     * @param  string $inbox_id Optional inbox ID to associate with the connector (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnectorWithOptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createConnectorWithOptionsAsyncWithHttpInfo($create_connector_with_options, $inbox_id = null, string $contentType = self::contentTypes['createConnectorWithOptions'][0])
    {
        $returnType = '\MailSlurp\Models\ConnectorDto';
        $request = $this->createConnectorWithOptionsRequest($create_connector_with_options, $inbox_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createConnectorWithOptions'
     *
     * @param  \MailSlurp\Models\CreateConnectorWithOptions $create_connector_with_options (required)
     * @param  string $inbox_id Optional inbox ID to associate with the connector (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createConnectorWithOptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createConnectorWithOptionsRequest($create_connector_with_options, $inbox_id = null, string $contentType = self::contentTypes['createConnectorWithOptions'][0])
    {

        // verify the required parameter 'create_connector_with_options' is set
        if ($create_connector_with_options === null || (is_array($create_connector_with_options) && count($create_connector_with_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_connector_with_options when calling createConnectorWithOptions'
            );
        }



        $resourcePath = '/connectors/withOptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $inbox_id,
            'inboxId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_connector_with_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($create_connector_with_options));
            } else {
                $httpBody = $create_connector_with_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAllConnector
     *
     * Delete all inbox connectors
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllConnector'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteAllConnector(string $contentType = self::contentTypes['deleteAllConnector'][0])
    {
        $this->deleteAllConnectorWithHttpInfo($contentType);
    }

    /**
     * Operation deleteAllConnectorWithHttpInfo
     *
     * Delete all inbox connectors
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllConnector'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAllConnectorWithHttpInfo(string $contentType = self::contentTypes['deleteAllConnector'][0])
    {
        $request = $this->deleteAllConnectorRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAllConnectorAsync
     *
     * Delete all inbox connectors
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAllConnectorAsync(string $contentType = self::contentTypes['deleteAllConnector'][0])
    {
        return $this->deleteAllConnectorAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAllConnectorAsyncWithHttpInfo
     *
     * Delete all inbox connectors
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAllConnectorAsyncWithHttpInfo(string $contentType = self::contentTypes['deleteAllConnector'][0])
    {
        $returnType = '';
        $request = $this->deleteAllConnectorRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAllConnector'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAllConnectorRequest(string $contentType = self::contentTypes['deleteAllConnector'][0])
    {


        $resourcePath = '/connectors';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteConnector
     *
     * Delete an inbox connector
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteConnector'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteConnector($id, string $contentType = self::contentTypes['deleteConnector'][0])
    {
        $this->deleteConnectorWithHttpInfo($id, $contentType);
    }

    /**
     * Operation deleteConnectorWithHttpInfo
     *
     * Delete an inbox connector
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteConnector'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteConnectorWithHttpInfo($id, string $contentType = self::contentTypes['deleteConnector'][0])
    {
        $request = $this->deleteConnectorRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteConnectorAsync
     *
     * Delete an inbox connector
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteConnectorAsync($id, string $contentType = self::contentTypes['deleteConnector'][0])
    {
        return $this->deleteConnectorAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteConnectorAsyncWithHttpInfo
     *
     * Delete an inbox connector
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteConnectorAsyncWithHttpInfo($id, string $contentType = self::contentTypes['deleteConnector'][0])
    {
        $returnType = '';
        $request = $this->deleteConnectorRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteConnector'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteConnectorRequest($id, string $contentType = self::contentTypes['deleteConnector'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteConnector'
            );
        }


        $resourcePath = '/connectors/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteConnectorImapConnection
     *
     * Delete an inbox connector IMAP connection
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteConnectorImapConnection'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteConnectorImapConnection($id, string $contentType = self::contentTypes['deleteConnectorImapConnection'][0])
    {
        $this->deleteConnectorImapConnectionWithHttpInfo($id, $contentType);
    }

    /**
     * Operation deleteConnectorImapConnectionWithHttpInfo
     *
     * Delete an inbox connector IMAP connection
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteConnectorImapConnection'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteConnectorImapConnectionWithHttpInfo($id, string $contentType = self::contentTypes['deleteConnectorImapConnection'][0])
    {
        $request = $this->deleteConnectorImapConnectionRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteConnectorImapConnectionAsync
     *
     * Delete an inbox connector IMAP connection
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteConnectorImapConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteConnectorImapConnectionAsync($id, string $contentType = self::contentTypes['deleteConnectorImapConnection'][0])
    {
        return $this->deleteConnectorImapConnectionAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteConnectorImapConnectionAsyncWithHttpInfo
     *
     * Delete an inbox connector IMAP connection
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteConnectorImapConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteConnectorImapConnectionAsyncWithHttpInfo($id, string $contentType = self::contentTypes['deleteConnectorImapConnection'][0])
    {
        $returnType = '';
        $request = $this->deleteConnectorImapConnectionRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteConnectorImapConnection'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteConnectorImapConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteConnectorImapConnectionRequest($id, string $contentType = self::contentTypes['deleteConnectorImapConnection'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteConnectorImapConnection'
            );
        }


        $resourcePath = '/connectors/{id}/imap';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteConnectorSmtpConnection
     *
     * Delete an inbox connector SMTP connection
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteConnectorSmtpConnection'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteConnectorSmtpConnection($id, string $contentType = self::contentTypes['deleteConnectorSmtpConnection'][0])
    {
        $this->deleteConnectorSmtpConnectionWithHttpInfo($id, $contentType);
    }

    /**
     * Operation deleteConnectorSmtpConnectionWithHttpInfo
     *
     * Delete an inbox connector SMTP connection
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteConnectorSmtpConnection'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteConnectorSmtpConnectionWithHttpInfo($id, string $contentType = self::contentTypes['deleteConnectorSmtpConnection'][0])
    {
        $request = $this->deleteConnectorSmtpConnectionRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteConnectorSmtpConnectionAsync
     *
     * Delete an inbox connector SMTP connection
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteConnectorSmtpConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteConnectorSmtpConnectionAsync($id, string $contentType = self::contentTypes['deleteConnectorSmtpConnection'][0])
    {
        return $this->deleteConnectorSmtpConnectionAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteConnectorSmtpConnectionAsyncWithHttpInfo
     *
     * Delete an inbox connector SMTP connection
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteConnectorSmtpConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteConnectorSmtpConnectionAsyncWithHttpInfo($id, string $contentType = self::contentTypes['deleteConnectorSmtpConnection'][0])
    {
        $returnType = '';
        $request = $this->deleteConnectorSmtpConnectionRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteConnectorSmtpConnection'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteConnectorSmtpConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteConnectorSmtpConnectionRequest($id, string $contentType = self::contentTypes['deleteConnectorSmtpConnection'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteConnectorSmtpConnection'
            );
        }


        $resourcePath = '/connectors/{id}/smtp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteConnectorSyncSettings
     *
     * Create an inbox connector sync settings
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteConnectorSyncSettings'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteConnectorSyncSettings($id, string $contentType = self::contentTypes['deleteConnectorSyncSettings'][0])
    {
        $this->deleteConnectorSyncSettingsWithHttpInfo($id, $contentType);
    }

    /**
     * Operation deleteConnectorSyncSettingsWithHttpInfo
     *
     * Create an inbox connector sync settings
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteConnectorSyncSettings'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteConnectorSyncSettingsWithHttpInfo($id, string $contentType = self::contentTypes['deleteConnectorSyncSettings'][0])
    {
        $request = $this->deleteConnectorSyncSettingsRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteConnectorSyncSettingsAsync
     *
     * Create an inbox connector sync settings
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteConnectorSyncSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteConnectorSyncSettingsAsync($id, string $contentType = self::contentTypes['deleteConnectorSyncSettings'][0])
    {
        return $this->deleteConnectorSyncSettingsAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteConnectorSyncSettingsAsyncWithHttpInfo
     *
     * Create an inbox connector sync settings
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteConnectorSyncSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteConnectorSyncSettingsAsyncWithHttpInfo($id, string $contentType = self::contentTypes['deleteConnectorSyncSettings'][0])
    {
        $returnType = '';
        $request = $this->deleteConnectorSyncSettingsRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteConnectorSyncSettings'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteConnectorSyncSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteConnectorSyncSettingsRequest($id, string $contentType = self::contentTypes['deleteConnectorSyncSettings'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteConnectorSyncSettings'
            );
        }


        $resourcePath = '/connectors/{id}/sync-settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllConnectorEvents
     *
     * Get all inbox connector events
     *
     * @param  string $id Optional connector ID (optional)
     * @param  int $page Optional page index in connector list pagination (optional, default to 0)
     * @param  int $size Optional page size in connector list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $event_type Filter by event type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllConnectorEvents'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\PageConnectorEvents
     */
    public function getAllConnectorEvents($id = null, $page = 0, $size = 20, $sort = 'ASC', $since = null, $before = null, $event_type = null, string $contentType = self::contentTypes['getAllConnectorEvents'][0])
    {
        list($response) = $this->getAllConnectorEventsWithHttpInfo($id, $page, $size, $sort, $since, $before, $event_type, $contentType);
        return $response;
    }

    /**
     * Operation getAllConnectorEventsWithHttpInfo
     *
     * Get all inbox connector events
     *
     * @param  string $id Optional connector ID (optional)
     * @param  int $page Optional page index in connector list pagination (optional, default to 0)
     * @param  int $size Optional page size in connector list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $event_type Filter by event type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllConnectorEvents'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\PageConnectorEvents, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllConnectorEventsWithHttpInfo($id = null, $page = 0, $size = 20, $sort = 'ASC', $since = null, $before = null, $event_type = null, string $contentType = self::contentTypes['getAllConnectorEvents'][0])
    {
        $request = $this->getAllConnectorEventsRequest($id, $page, $size, $sort, $since, $before, $event_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\PageConnectorEvents' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\PageConnectorEvents' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\PageConnectorEvents', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\PageConnectorEvents';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\PageConnectorEvents',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllConnectorEventsAsync
     *
     * Get all inbox connector events
     *
     * @param  string $id Optional connector ID (optional)
     * @param  int $page Optional page index in connector list pagination (optional, default to 0)
     * @param  int $size Optional page size in connector list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $event_type Filter by event type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllConnectorEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllConnectorEventsAsync($id = null, $page = 0, $size = 20, $sort = 'ASC', $since = null, $before = null, $event_type = null, string $contentType = self::contentTypes['getAllConnectorEvents'][0])
    {
        return $this->getAllConnectorEventsAsyncWithHttpInfo($id, $page, $size, $sort, $since, $before, $event_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllConnectorEventsAsyncWithHttpInfo
     *
     * Get all inbox connector events
     *
     * @param  string $id Optional connector ID (optional)
     * @param  int $page Optional page index in connector list pagination (optional, default to 0)
     * @param  int $size Optional page size in connector list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $event_type Filter by event type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllConnectorEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllConnectorEventsAsyncWithHttpInfo($id = null, $page = 0, $size = 20, $sort = 'ASC', $since = null, $before = null, $event_type = null, string $contentType = self::contentTypes['getAllConnectorEvents'][0])
    {
        $returnType = '\MailSlurp\Models\PageConnectorEvents';
        $request = $this->getAllConnectorEventsRequest($id, $page, $size, $sort, $since, $before, $event_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllConnectorEvents'
     *
     * @param  string $id Optional connector ID (optional)
     * @param  int $page Optional page index in connector list pagination (optional, default to 0)
     * @param  int $size Optional page size in connector list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $event_type Filter by event type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllConnectorEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAllConnectorEventsRequest($id = null, $page = 0, $size = 20, $sort = 'ASC', $since = null, $before = null, $event_type = null, string $contentType = self::contentTypes['getAllConnectorEvents'][0])
    {









        $resourcePath = '/connectors/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size,
            'size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $since,
            'since', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $before,
            'before', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $event_type,
            'eventType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConnector
     *
     * Get an inbox connector
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnector'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\ConnectorDto
     */
    public function getConnector($id, string $contentType = self::contentTypes['getConnector'][0])
    {
        list($response) = $this->getConnectorWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getConnectorWithHttpInfo
     *
     * Get an inbox connector
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnector'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\ConnectorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConnectorWithHttpInfo($id, string $contentType = self::contentTypes['getConnector'][0])
    {
        $request = $this->getConnectorRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\ConnectorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\ConnectorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\ConnectorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\ConnectorDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\ConnectorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConnectorAsync
     *
     * Get an inbox connector
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConnectorAsync($id, string $contentType = self::contentTypes['getConnector'][0])
    {
        return $this->getConnectorAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConnectorAsyncWithHttpInfo
     *
     * Get an inbox connector
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConnectorAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getConnector'][0])
    {
        $returnType = '\MailSlurp\Models\ConnectorDto';
        $request = $this->getConnectorRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConnector'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getConnectorRequest($id, string $contentType = self::contentTypes['getConnector'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getConnector'
            );
        }


        $resourcePath = '/connectors/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConnectorByEmailAddress
     *
     * Get connector by email address
     *
     * @param  string $email_address Email address to search for connector by (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorByEmailAddress'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\OptionalConnectorDto
     */
    public function getConnectorByEmailAddress($email_address, string $contentType = self::contentTypes['getConnectorByEmailAddress'][0])
    {
        list($response) = $this->getConnectorByEmailAddressWithHttpInfo($email_address, $contentType);
        return $response;
    }

    /**
     * Operation getConnectorByEmailAddressWithHttpInfo
     *
     * Get connector by email address
     *
     * @param  string $email_address Email address to search for connector by (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorByEmailAddress'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\OptionalConnectorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConnectorByEmailAddressWithHttpInfo($email_address, string $contentType = self::contentTypes['getConnectorByEmailAddress'][0])
    {
        $request = $this->getConnectorByEmailAddressRequest($email_address, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\OptionalConnectorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\OptionalConnectorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\OptionalConnectorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\OptionalConnectorDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\OptionalConnectorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConnectorByEmailAddressAsync
     *
     * Get connector by email address
     *
     * @param  string $email_address Email address to search for connector by (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorByEmailAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConnectorByEmailAddressAsync($email_address, string $contentType = self::contentTypes['getConnectorByEmailAddress'][0])
    {
        return $this->getConnectorByEmailAddressAsyncWithHttpInfo($email_address, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConnectorByEmailAddressAsyncWithHttpInfo
     *
     * Get connector by email address
     *
     * @param  string $email_address Email address to search for connector by (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorByEmailAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConnectorByEmailAddressAsyncWithHttpInfo($email_address, string $contentType = self::contentTypes['getConnectorByEmailAddress'][0])
    {
        $returnType = '\MailSlurp\Models\OptionalConnectorDto';
        $request = $this->getConnectorByEmailAddressRequest($email_address, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConnectorByEmailAddress'
     *
     * @param  string $email_address Email address to search for connector by (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorByEmailAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getConnectorByEmailAddressRequest($email_address, string $contentType = self::contentTypes['getConnectorByEmailAddress'][0])
    {

        // verify the required parameter 'email_address' is set
        if ($email_address === null || (is_array($email_address) && count($email_address) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $email_address when calling getConnectorByEmailAddress'
            );
        }


        $resourcePath = '/connectors/by-email-address';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email_address,
            'emailAddress', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConnectorByInboxId
     *
     * Get connector by inbox ID
     *
     * @param  string $inbox_id Inbox ID to search for connector by (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorByInboxId'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\OptionalConnectorDto
     */
    public function getConnectorByInboxId($inbox_id, string $contentType = self::contentTypes['getConnectorByInboxId'][0])
    {
        list($response) = $this->getConnectorByInboxIdWithHttpInfo($inbox_id, $contentType);
        return $response;
    }

    /**
     * Operation getConnectorByInboxIdWithHttpInfo
     *
     * Get connector by inbox ID
     *
     * @param  string $inbox_id Inbox ID to search for connector by (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorByInboxId'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\OptionalConnectorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConnectorByInboxIdWithHttpInfo($inbox_id, string $contentType = self::contentTypes['getConnectorByInboxId'][0])
    {
        $request = $this->getConnectorByInboxIdRequest($inbox_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\OptionalConnectorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\OptionalConnectorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\OptionalConnectorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\OptionalConnectorDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\OptionalConnectorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConnectorByInboxIdAsync
     *
     * Get connector by inbox ID
     *
     * @param  string $inbox_id Inbox ID to search for connector by (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorByInboxId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConnectorByInboxIdAsync($inbox_id, string $contentType = self::contentTypes['getConnectorByInboxId'][0])
    {
        return $this->getConnectorByInboxIdAsyncWithHttpInfo($inbox_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConnectorByInboxIdAsyncWithHttpInfo
     *
     * Get connector by inbox ID
     *
     * @param  string $inbox_id Inbox ID to search for connector by (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorByInboxId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConnectorByInboxIdAsyncWithHttpInfo($inbox_id, string $contentType = self::contentTypes['getConnectorByInboxId'][0])
    {
        $returnType = '\MailSlurp\Models\OptionalConnectorDto';
        $request = $this->getConnectorByInboxIdRequest($inbox_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConnectorByInboxId'
     *
     * @param  string $inbox_id Inbox ID to search for connector by (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorByInboxId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getConnectorByInboxIdRequest($inbox_id, string $contentType = self::contentTypes['getConnectorByInboxId'][0])
    {

        // verify the required parameter 'inbox_id' is set
        if ($inbox_id === null || (is_array($inbox_id) && count($inbox_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inbox_id when calling getConnectorByInboxId'
            );
        }


        $resourcePath = '/connectors/by-inbox-id';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $inbox_id,
            'inboxId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConnectorByName
     *
     * Get connector by name
     *
     * @param  string $name Name to search for connector by (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorByName'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\OptionalConnectorDto
     */
    public function getConnectorByName($name, string $contentType = self::contentTypes['getConnectorByName'][0])
    {
        list($response) = $this->getConnectorByNameWithHttpInfo($name, $contentType);
        return $response;
    }

    /**
     * Operation getConnectorByNameWithHttpInfo
     *
     * Get connector by name
     *
     * @param  string $name Name to search for connector by (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorByName'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\OptionalConnectorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConnectorByNameWithHttpInfo($name, string $contentType = self::contentTypes['getConnectorByName'][0])
    {
        $request = $this->getConnectorByNameRequest($name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\OptionalConnectorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\OptionalConnectorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\OptionalConnectorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\OptionalConnectorDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\OptionalConnectorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConnectorByNameAsync
     *
     * Get connector by name
     *
     * @param  string $name Name to search for connector by (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorByName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConnectorByNameAsync($name, string $contentType = self::contentTypes['getConnectorByName'][0])
    {
        return $this->getConnectorByNameAsyncWithHttpInfo($name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConnectorByNameAsyncWithHttpInfo
     *
     * Get connector by name
     *
     * @param  string $name Name to search for connector by (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorByName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConnectorByNameAsyncWithHttpInfo($name, string $contentType = self::contentTypes['getConnectorByName'][0])
    {
        $returnType = '\MailSlurp\Models\OptionalConnectorDto';
        $request = $this->getConnectorByNameRequest($name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConnectorByName'
     *
     * @param  string $name Name to search for connector by (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorByName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getConnectorByNameRequest($name, string $contentType = self::contentTypes['getConnectorByName'][0])
    {

        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling getConnectorByName'
            );
        }


        $resourcePath = '/connectors/by-name';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConnectorEvent
     *
     * Get an inbox connector event
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorEvent'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\ConnectorEventDto
     */
    public function getConnectorEvent($id, string $contentType = self::contentTypes['getConnectorEvent'][0])
    {
        list($response) = $this->getConnectorEventWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getConnectorEventWithHttpInfo
     *
     * Get an inbox connector event
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorEvent'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\ConnectorEventDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConnectorEventWithHttpInfo($id, string $contentType = self::contentTypes['getConnectorEvent'][0])
    {
        $request = $this->getConnectorEventRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\ConnectorEventDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\ConnectorEventDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\ConnectorEventDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\ConnectorEventDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\ConnectorEventDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConnectorEventAsync
     *
     * Get an inbox connector event
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorEvent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConnectorEventAsync($id, string $contentType = self::contentTypes['getConnectorEvent'][0])
    {
        return $this->getConnectorEventAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConnectorEventAsyncWithHttpInfo
     *
     * Get an inbox connector event
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorEvent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConnectorEventAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getConnectorEvent'][0])
    {
        $returnType = '\MailSlurp\Models\ConnectorEventDto';
        $request = $this->getConnectorEventRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConnectorEvent'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorEvent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getConnectorEventRequest($id, string $contentType = self::contentTypes['getConnectorEvent'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getConnectorEvent'
            );
        }


        $resourcePath = '/connectors/events/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConnectorEvents
     *
     * Get an inbox connector events
     *
     * @param  string $id id (required)
     * @param  int $page Optional page index in connector list pagination (optional, default to 0)
     * @param  int $size Optional page size in connector list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $event_type Filter by event type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorEvents'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\PageConnectorEvents
     */
    public function getConnectorEvents($id, $page = 0, $size = 20, $sort = 'ASC', $since = null, $before = null, $event_type = null, string $contentType = self::contentTypes['getConnectorEvents'][0])
    {
        list($response) = $this->getConnectorEventsWithHttpInfo($id, $page, $size, $sort, $since, $before, $event_type, $contentType);
        return $response;
    }

    /**
     * Operation getConnectorEventsWithHttpInfo
     *
     * Get an inbox connector events
     *
     * @param  string $id (required)
     * @param  int $page Optional page index in connector list pagination (optional, default to 0)
     * @param  int $size Optional page size in connector list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $event_type Filter by event type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorEvents'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\PageConnectorEvents, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConnectorEventsWithHttpInfo($id, $page = 0, $size = 20, $sort = 'ASC', $since = null, $before = null, $event_type = null, string $contentType = self::contentTypes['getConnectorEvents'][0])
    {
        $request = $this->getConnectorEventsRequest($id, $page, $size, $sort, $since, $before, $event_type, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\PageConnectorEvents' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\PageConnectorEvents' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\PageConnectorEvents', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\PageConnectorEvents';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\PageConnectorEvents',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConnectorEventsAsync
     *
     * Get an inbox connector events
     *
     * @param  string $id (required)
     * @param  int $page Optional page index in connector list pagination (optional, default to 0)
     * @param  int $size Optional page size in connector list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $event_type Filter by event type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConnectorEventsAsync($id, $page = 0, $size = 20, $sort = 'ASC', $since = null, $before = null, $event_type = null, string $contentType = self::contentTypes['getConnectorEvents'][0])
    {
        return $this->getConnectorEventsAsyncWithHttpInfo($id, $page, $size, $sort, $since, $before, $event_type, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConnectorEventsAsyncWithHttpInfo
     *
     * Get an inbox connector events
     *
     * @param  string $id (required)
     * @param  int $page Optional page index in connector list pagination (optional, default to 0)
     * @param  int $size Optional page size in connector list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $event_type Filter by event type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConnectorEventsAsyncWithHttpInfo($id, $page = 0, $size = 20, $sort = 'ASC', $since = null, $before = null, $event_type = null, string $contentType = self::contentTypes['getConnectorEvents'][0])
    {
        $returnType = '\MailSlurp\Models\PageConnectorEvents';
        $request = $this->getConnectorEventsRequest($id, $page, $size, $sort, $since, $before, $event_type, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConnectorEvents'
     *
     * @param  string $id (required)
     * @param  int $page Optional page index in connector list pagination (optional, default to 0)
     * @param  int $size Optional page size in connector list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $event_type Filter by event type (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorEvents'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getConnectorEventsRequest($id, $page = 0, $size = 20, $sort = 'ASC', $since = null, $before = null, $event_type = null, string $contentType = self::contentTypes['getConnectorEvents'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getConnectorEvents'
            );
        }








        $resourcePath = '/connectors/{id}/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size,
            'size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $since,
            'since', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $before,
            'before', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $event_type,
            'eventType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConnectorImapConnection
     *
     * Get an inbox connector IMAP connection
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorImapConnection'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\OptionalConnectorImapConnectionDto
     */
    public function getConnectorImapConnection($id, string $contentType = self::contentTypes['getConnectorImapConnection'][0])
    {
        list($response) = $this->getConnectorImapConnectionWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getConnectorImapConnectionWithHttpInfo
     *
     * Get an inbox connector IMAP connection
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorImapConnection'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\OptionalConnectorImapConnectionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConnectorImapConnectionWithHttpInfo($id, string $contentType = self::contentTypes['getConnectorImapConnection'][0])
    {
        $request = $this->getConnectorImapConnectionRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\OptionalConnectorImapConnectionDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\OptionalConnectorImapConnectionDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\OptionalConnectorImapConnectionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\OptionalConnectorImapConnectionDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\OptionalConnectorImapConnectionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConnectorImapConnectionAsync
     *
     * Get an inbox connector IMAP connection
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorImapConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConnectorImapConnectionAsync($id, string $contentType = self::contentTypes['getConnectorImapConnection'][0])
    {
        return $this->getConnectorImapConnectionAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConnectorImapConnectionAsyncWithHttpInfo
     *
     * Get an inbox connector IMAP connection
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorImapConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConnectorImapConnectionAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getConnectorImapConnection'][0])
    {
        $returnType = '\MailSlurp\Models\OptionalConnectorImapConnectionDto';
        $request = $this->getConnectorImapConnectionRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConnectorImapConnection'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorImapConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getConnectorImapConnectionRequest($id, string $contentType = self::contentTypes['getConnectorImapConnection'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getConnectorImapConnection'
            );
        }


        $resourcePath = '/connectors/{id}/imap';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConnectorProviderSettings
     *
     * Get SMTP and IMAP connection settings for common mail providers
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorProviderSettings'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\ConnectorProviderSettingsDto
     */
    public function getConnectorProviderSettings(string $contentType = self::contentTypes['getConnectorProviderSettings'][0])
    {
        list($response) = $this->getConnectorProviderSettingsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getConnectorProviderSettingsWithHttpInfo
     *
     * Get SMTP and IMAP connection settings for common mail providers
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorProviderSettings'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\ConnectorProviderSettingsDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConnectorProviderSettingsWithHttpInfo(string $contentType = self::contentTypes['getConnectorProviderSettings'][0])
    {
        $request = $this->getConnectorProviderSettingsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\ConnectorProviderSettingsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\ConnectorProviderSettingsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\ConnectorProviderSettingsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\ConnectorProviderSettingsDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\ConnectorProviderSettingsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConnectorProviderSettingsAsync
     *
     * Get SMTP and IMAP connection settings for common mail providers
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorProviderSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConnectorProviderSettingsAsync(string $contentType = self::contentTypes['getConnectorProviderSettings'][0])
    {
        return $this->getConnectorProviderSettingsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConnectorProviderSettingsAsyncWithHttpInfo
     *
     * Get SMTP and IMAP connection settings for common mail providers
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorProviderSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConnectorProviderSettingsAsyncWithHttpInfo(string $contentType = self::contentTypes['getConnectorProviderSettings'][0])
    {
        $returnType = '\MailSlurp\Models\ConnectorProviderSettingsDto';
        $request = $this->getConnectorProviderSettingsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConnectorProviderSettings'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorProviderSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getConnectorProviderSettingsRequest(string $contentType = self::contentTypes['getConnectorProviderSettings'][0])
    {


        $resourcePath = '/connectors/provider-settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConnectorSmtpConnection
     *
     * Get an inbox connector SMTP connection
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorSmtpConnection'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\OptionalConnectorSmtpConnectionDto
     */
    public function getConnectorSmtpConnection($id, string $contentType = self::contentTypes['getConnectorSmtpConnection'][0])
    {
        list($response) = $this->getConnectorSmtpConnectionWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getConnectorSmtpConnectionWithHttpInfo
     *
     * Get an inbox connector SMTP connection
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorSmtpConnection'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\OptionalConnectorSmtpConnectionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConnectorSmtpConnectionWithHttpInfo($id, string $contentType = self::contentTypes['getConnectorSmtpConnection'][0])
    {
        $request = $this->getConnectorSmtpConnectionRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\OptionalConnectorSmtpConnectionDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\OptionalConnectorSmtpConnectionDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\OptionalConnectorSmtpConnectionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\OptionalConnectorSmtpConnectionDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\OptionalConnectorSmtpConnectionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConnectorSmtpConnectionAsync
     *
     * Get an inbox connector SMTP connection
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorSmtpConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConnectorSmtpConnectionAsync($id, string $contentType = self::contentTypes['getConnectorSmtpConnection'][0])
    {
        return $this->getConnectorSmtpConnectionAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConnectorSmtpConnectionAsyncWithHttpInfo
     *
     * Get an inbox connector SMTP connection
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorSmtpConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConnectorSmtpConnectionAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getConnectorSmtpConnection'][0])
    {
        $returnType = '\MailSlurp\Models\OptionalConnectorSmtpConnectionDto';
        $request = $this->getConnectorSmtpConnectionRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConnectorSmtpConnection'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorSmtpConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getConnectorSmtpConnectionRequest($id, string $contentType = self::contentTypes['getConnectorSmtpConnection'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getConnectorSmtpConnection'
            );
        }


        $resourcePath = '/connectors/{id}/smtp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConnectorSyncSettings
     *
     * Get an inbox connector sync settings
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorSyncSettings'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\OptionalConnectorSyncSettingsDto
     */
    public function getConnectorSyncSettings($id, string $contentType = self::contentTypes['getConnectorSyncSettings'][0])
    {
        list($response) = $this->getConnectorSyncSettingsWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getConnectorSyncSettingsWithHttpInfo
     *
     * Get an inbox connector sync settings
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorSyncSettings'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\OptionalConnectorSyncSettingsDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConnectorSyncSettingsWithHttpInfo($id, string $contentType = self::contentTypes['getConnectorSyncSettings'][0])
    {
        $request = $this->getConnectorSyncSettingsRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\OptionalConnectorSyncSettingsDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\OptionalConnectorSyncSettingsDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\OptionalConnectorSyncSettingsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\OptionalConnectorSyncSettingsDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\OptionalConnectorSyncSettingsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConnectorSyncSettingsAsync
     *
     * Get an inbox connector sync settings
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorSyncSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConnectorSyncSettingsAsync($id, string $contentType = self::contentTypes['getConnectorSyncSettings'][0])
    {
        return $this->getConnectorSyncSettingsAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConnectorSyncSettingsAsyncWithHttpInfo
     *
     * Get an inbox connector sync settings
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorSyncSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConnectorSyncSettingsAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getConnectorSyncSettings'][0])
    {
        $returnType = '\MailSlurp\Models\OptionalConnectorSyncSettingsDto';
        $request = $this->getConnectorSyncSettingsRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConnectorSyncSettings'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectorSyncSettings'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getConnectorSyncSettingsRequest($id, string $contentType = self::contentTypes['getConnectorSyncSettings'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getConnectorSyncSettings'
            );
        }


        $resourcePath = '/connectors/{id}/sync-settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConnectors
     *
     * Get inbox connectors
     *
     * @param  int $page Optional page index in connector list pagination (optional, default to 0)
     * @param  int $size Optional page size in connector list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectors'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\PageConnector
     */
    public function getConnectors($page = 0, $size = 20, $sort = 'ASC', $since = null, $before = null, string $contentType = self::contentTypes['getConnectors'][0])
    {
        list($response) = $this->getConnectorsWithHttpInfo($page, $size, $sort, $since, $before, $contentType);
        return $response;
    }

    /**
     * Operation getConnectorsWithHttpInfo
     *
     * Get inbox connectors
     *
     * @param  int $page Optional page index in connector list pagination (optional, default to 0)
     * @param  int $size Optional page size in connector list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectors'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\PageConnector, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConnectorsWithHttpInfo($page = 0, $size = 20, $sort = 'ASC', $since = null, $before = null, string $contentType = self::contentTypes['getConnectors'][0])
    {
        $request = $this->getConnectorsRequest($page, $size, $sort, $since, $before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\PageConnector' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\PageConnector' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\PageConnector', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\PageConnector';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\PageConnector',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConnectorsAsync
     *
     * Get inbox connectors
     *
     * @param  int $page Optional page index in connector list pagination (optional, default to 0)
     * @param  int $size Optional page size in connector list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectors'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConnectorsAsync($page = 0, $size = 20, $sort = 'ASC', $since = null, $before = null, string $contentType = self::contentTypes['getConnectors'][0])
    {
        return $this->getConnectorsAsyncWithHttpInfo($page, $size, $sort, $since, $before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConnectorsAsyncWithHttpInfo
     *
     * Get inbox connectors
     *
     * @param  int $page Optional page index in connector list pagination (optional, default to 0)
     * @param  int $size Optional page size in connector list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectors'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConnectorsAsyncWithHttpInfo($page = 0, $size = 20, $sort = 'ASC', $since = null, $before = null, string $contentType = self::contentTypes['getConnectors'][0])
    {
        $returnType = '\MailSlurp\Models\PageConnector';
        $request = $this->getConnectorsRequest($page, $size, $sort, $since, $before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConnectors'
     *
     * @param  int $page Optional page index in connector list pagination (optional, default to 0)
     * @param  int $size Optional page size in connector list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getConnectors'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getConnectorsRequest($page = 0, $size = 20, $sort = 'ASC', $since = null, $before = null, string $contentType = self::contentTypes['getConnectors'][0])
    {







        $resourcePath = '/connectors';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size,
            'size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $since,
            'since', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $before,
            'before', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendEmailFromConnector
     *
     * Send from an inbox connector
     *
     * @param  string $id id (required)
     * @param  \MailSlurp\Models\SendEmailOptions $send_email_options send_email_options (required)
     * @param  bool $use_fallback use_fallback (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendEmailFromConnector'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\SentEmailDto
     */
    public function sendEmailFromConnector($id, $send_email_options, $use_fallback = null, string $contentType = self::contentTypes['sendEmailFromConnector'][0])
    {
        list($response) = $this->sendEmailFromConnectorWithHttpInfo($id, $send_email_options, $use_fallback, $contentType);
        return $response;
    }

    /**
     * Operation sendEmailFromConnectorWithHttpInfo
     *
     * Send from an inbox connector
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\SendEmailOptions $send_email_options (required)
     * @param  bool $use_fallback (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendEmailFromConnector'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\SentEmailDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function sendEmailFromConnectorWithHttpInfo($id, $send_email_options, $use_fallback = null, string $contentType = self::contentTypes['sendEmailFromConnector'][0])
    {
        $request = $this->sendEmailFromConnectorRequest($id, $send_email_options, $use_fallback, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\SentEmailDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\SentEmailDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\SentEmailDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\SentEmailDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\SentEmailDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sendEmailFromConnectorAsync
     *
     * Send from an inbox connector
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\SendEmailOptions $send_email_options (required)
     * @param  bool $use_fallback (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendEmailFromConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendEmailFromConnectorAsync($id, $send_email_options, $use_fallback = null, string $contentType = self::contentTypes['sendEmailFromConnector'][0])
    {
        return $this->sendEmailFromConnectorAsyncWithHttpInfo($id, $send_email_options, $use_fallback, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendEmailFromConnectorAsyncWithHttpInfo
     *
     * Send from an inbox connector
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\SendEmailOptions $send_email_options (required)
     * @param  bool $use_fallback (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendEmailFromConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendEmailFromConnectorAsyncWithHttpInfo($id, $send_email_options, $use_fallback = null, string $contentType = self::contentTypes['sendEmailFromConnector'][0])
    {
        $returnType = '\MailSlurp\Models\SentEmailDto';
        $request = $this->sendEmailFromConnectorRequest($id, $send_email_options, $use_fallback, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendEmailFromConnector'
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\SendEmailOptions $send_email_options (required)
     * @param  bool $use_fallback (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendEmailFromConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function sendEmailFromConnectorRequest($id, $send_email_options, $use_fallback = null, string $contentType = self::contentTypes['sendEmailFromConnector'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling sendEmailFromConnector'
            );
        }

        // verify the required parameter 'send_email_options' is set
        if ($send_email_options === null || (is_array($send_email_options) && count($send_email_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $send_email_options when calling sendEmailFromConnector'
            );
        }



        $resourcePath = '/connectors/{id}/send';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $use_fallback,
            'useFallback', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($send_email_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($send_email_options));
            } else {
                $httpBody = $send_email_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation syncConnector
     *
     * Sync an inbox connector
     *
     * @param  string $id id (required)
     * @param  \DateTime $since Date to request emails since (optional)
     * @param  string $folder Which folder to sync emails with (optional)
     * @param  bool $logging Enable or disable logging for the sync operation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncConnector'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\ConnectorSyncRequestResult
     */
    public function syncConnector($id, $since = null, $folder = null, $logging = null, string $contentType = self::contentTypes['syncConnector'][0])
    {
        list($response) = $this->syncConnectorWithHttpInfo($id, $since, $folder, $logging, $contentType);
        return $response;
    }

    /**
     * Operation syncConnectorWithHttpInfo
     *
     * Sync an inbox connector
     *
     * @param  string $id (required)
     * @param  \DateTime $since Date to request emails since (optional)
     * @param  string $folder Which folder to sync emails with (optional)
     * @param  bool $logging Enable or disable logging for the sync operation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncConnector'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\ConnectorSyncRequestResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function syncConnectorWithHttpInfo($id, $since = null, $folder = null, $logging = null, string $contentType = self::contentTypes['syncConnector'][0])
    {
        $request = $this->syncConnectorRequest($id, $since, $folder, $logging, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\ConnectorSyncRequestResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\ConnectorSyncRequestResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\ConnectorSyncRequestResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\ConnectorSyncRequestResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\ConnectorSyncRequestResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation syncConnectorAsync
     *
     * Sync an inbox connector
     *
     * @param  string $id (required)
     * @param  \DateTime $since Date to request emails since (optional)
     * @param  string $folder Which folder to sync emails with (optional)
     * @param  bool $logging Enable or disable logging for the sync operation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncConnectorAsync($id, $since = null, $folder = null, $logging = null, string $contentType = self::contentTypes['syncConnector'][0])
    {
        return $this->syncConnectorAsyncWithHttpInfo($id, $since, $folder, $logging, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation syncConnectorAsyncWithHttpInfo
     *
     * Sync an inbox connector
     *
     * @param  string $id (required)
     * @param  \DateTime $since Date to request emails since (optional)
     * @param  string $folder Which folder to sync emails with (optional)
     * @param  bool $logging Enable or disable logging for the sync operation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function syncConnectorAsyncWithHttpInfo($id, $since = null, $folder = null, $logging = null, string $contentType = self::contentTypes['syncConnector'][0])
    {
        $returnType = '\MailSlurp\Models\ConnectorSyncRequestResult';
        $request = $this->syncConnectorRequest($id, $since, $folder, $logging, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'syncConnector'
     *
     * @param  string $id (required)
     * @param  \DateTime $since Date to request emails since (optional)
     * @param  string $folder Which folder to sync emails with (optional)
     * @param  bool $logging Enable or disable logging for the sync operation (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['syncConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function syncConnectorRequest($id, $since = null, $folder = null, $logging = null, string $contentType = self::contentTypes['syncConnector'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling syncConnector'
            );
        }





        $resourcePath = '/connectors/{id}/sync';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $since,
            'since', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $folder,
            'folder', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $logging,
            'logging', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation testConnectorImapConnection
     *
     * Test an inbox connector IMAP connection
     *
     * @param  string $id id (required)
     * @param  \MailSlurp\Models\CreateConnectorImapConnectionOptions $create_connector_imap_connection_options create_connector_imap_connection_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testConnectorImapConnection'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\ConnectorImapConnectionTestResult
     */
    public function testConnectorImapConnection($id, $create_connector_imap_connection_options = null, string $contentType = self::contentTypes['testConnectorImapConnection'][0])
    {
        list($response) = $this->testConnectorImapConnectionWithHttpInfo($id, $create_connector_imap_connection_options, $contentType);
        return $response;
    }

    /**
     * Operation testConnectorImapConnectionWithHttpInfo
     *
     * Test an inbox connector IMAP connection
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorImapConnectionOptions $create_connector_imap_connection_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testConnectorImapConnection'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\ConnectorImapConnectionTestResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function testConnectorImapConnectionWithHttpInfo($id, $create_connector_imap_connection_options = null, string $contentType = self::contentTypes['testConnectorImapConnection'][0])
    {
        $request = $this->testConnectorImapConnectionRequest($id, $create_connector_imap_connection_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\ConnectorImapConnectionTestResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\ConnectorImapConnectionTestResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\ConnectorImapConnectionTestResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\ConnectorImapConnectionTestResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\ConnectorImapConnectionTestResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation testConnectorImapConnectionAsync
     *
     * Test an inbox connector IMAP connection
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorImapConnectionOptions $create_connector_imap_connection_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testConnectorImapConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function testConnectorImapConnectionAsync($id, $create_connector_imap_connection_options = null, string $contentType = self::contentTypes['testConnectorImapConnection'][0])
    {
        return $this->testConnectorImapConnectionAsyncWithHttpInfo($id, $create_connector_imap_connection_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation testConnectorImapConnectionAsyncWithHttpInfo
     *
     * Test an inbox connector IMAP connection
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorImapConnectionOptions $create_connector_imap_connection_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testConnectorImapConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function testConnectorImapConnectionAsyncWithHttpInfo($id, $create_connector_imap_connection_options = null, string $contentType = self::contentTypes['testConnectorImapConnection'][0])
    {
        $returnType = '\MailSlurp\Models\ConnectorImapConnectionTestResult';
        $request = $this->testConnectorImapConnectionRequest($id, $create_connector_imap_connection_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'testConnectorImapConnection'
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorImapConnectionOptions $create_connector_imap_connection_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testConnectorImapConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function testConnectorImapConnectionRequest($id, $create_connector_imap_connection_options = null, string $contentType = self::contentTypes['testConnectorImapConnection'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling testConnectorImapConnection'
            );
        }



        $resourcePath = '/connectors/{id}/imap/test';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_connector_imap_connection_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($create_connector_imap_connection_options));
            } else {
                $httpBody = $create_connector_imap_connection_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation testConnectorImapConnectionOptions
     *
     * Test an inbox connector IMAP connection options
     *
     * @param  \MailSlurp\Models\CreateConnectorImapConnectionOptions $create_connector_imap_connection_options create_connector_imap_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testConnectorImapConnectionOptions'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\ConnectorImapConnectionTestResult
     */
    public function testConnectorImapConnectionOptions($create_connector_imap_connection_options, string $contentType = self::contentTypes['testConnectorImapConnectionOptions'][0])
    {
        list($response) = $this->testConnectorImapConnectionOptionsWithHttpInfo($create_connector_imap_connection_options, $contentType);
        return $response;
    }

    /**
     * Operation testConnectorImapConnectionOptionsWithHttpInfo
     *
     * Test an inbox connector IMAP connection options
     *
     * @param  \MailSlurp\Models\CreateConnectorImapConnectionOptions $create_connector_imap_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testConnectorImapConnectionOptions'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\ConnectorImapConnectionTestResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function testConnectorImapConnectionOptionsWithHttpInfo($create_connector_imap_connection_options, string $contentType = self::contentTypes['testConnectorImapConnectionOptions'][0])
    {
        $request = $this->testConnectorImapConnectionOptionsRequest($create_connector_imap_connection_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\ConnectorImapConnectionTestResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\ConnectorImapConnectionTestResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\ConnectorImapConnectionTestResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\ConnectorImapConnectionTestResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\ConnectorImapConnectionTestResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation testConnectorImapConnectionOptionsAsync
     *
     * Test an inbox connector IMAP connection options
     *
     * @param  \MailSlurp\Models\CreateConnectorImapConnectionOptions $create_connector_imap_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testConnectorImapConnectionOptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function testConnectorImapConnectionOptionsAsync($create_connector_imap_connection_options, string $contentType = self::contentTypes['testConnectorImapConnectionOptions'][0])
    {
        return $this->testConnectorImapConnectionOptionsAsyncWithHttpInfo($create_connector_imap_connection_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation testConnectorImapConnectionOptionsAsyncWithHttpInfo
     *
     * Test an inbox connector IMAP connection options
     *
     * @param  \MailSlurp\Models\CreateConnectorImapConnectionOptions $create_connector_imap_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testConnectorImapConnectionOptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function testConnectorImapConnectionOptionsAsyncWithHttpInfo($create_connector_imap_connection_options, string $contentType = self::contentTypes['testConnectorImapConnectionOptions'][0])
    {
        $returnType = '\MailSlurp\Models\ConnectorImapConnectionTestResult';
        $request = $this->testConnectorImapConnectionOptionsRequest($create_connector_imap_connection_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'testConnectorImapConnectionOptions'
     *
     * @param  \MailSlurp\Models\CreateConnectorImapConnectionOptions $create_connector_imap_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testConnectorImapConnectionOptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function testConnectorImapConnectionOptionsRequest($create_connector_imap_connection_options, string $contentType = self::contentTypes['testConnectorImapConnectionOptions'][0])
    {

        // verify the required parameter 'create_connector_imap_connection_options' is set
        if ($create_connector_imap_connection_options === null || (is_array($create_connector_imap_connection_options) && count($create_connector_imap_connection_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_connector_imap_connection_options when calling testConnectorImapConnectionOptions'
            );
        }


        $resourcePath = '/connectors/connections/imap/test';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_connector_imap_connection_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($create_connector_imap_connection_options));
            } else {
                $httpBody = $create_connector_imap_connection_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation testConnectorSmtpConnection
     *
     * Test an inbox connector SMTP connection
     *
     * @param  string $id id (required)
     * @param  \MailSlurp\Models\CreateConnectorSmtpConnectionOptions $create_connector_smtp_connection_options create_connector_smtp_connection_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testConnectorSmtpConnection'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\ConnectorSmtpConnectionTestResult
     */
    public function testConnectorSmtpConnection($id, $create_connector_smtp_connection_options = null, string $contentType = self::contentTypes['testConnectorSmtpConnection'][0])
    {
        list($response) = $this->testConnectorSmtpConnectionWithHttpInfo($id, $create_connector_smtp_connection_options, $contentType);
        return $response;
    }

    /**
     * Operation testConnectorSmtpConnectionWithHttpInfo
     *
     * Test an inbox connector SMTP connection
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorSmtpConnectionOptions $create_connector_smtp_connection_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testConnectorSmtpConnection'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\ConnectorSmtpConnectionTestResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function testConnectorSmtpConnectionWithHttpInfo($id, $create_connector_smtp_connection_options = null, string $contentType = self::contentTypes['testConnectorSmtpConnection'][0])
    {
        $request = $this->testConnectorSmtpConnectionRequest($id, $create_connector_smtp_connection_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\ConnectorSmtpConnectionTestResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\ConnectorSmtpConnectionTestResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\ConnectorSmtpConnectionTestResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\ConnectorSmtpConnectionTestResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\ConnectorSmtpConnectionTestResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation testConnectorSmtpConnectionAsync
     *
     * Test an inbox connector SMTP connection
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorSmtpConnectionOptions $create_connector_smtp_connection_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testConnectorSmtpConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function testConnectorSmtpConnectionAsync($id, $create_connector_smtp_connection_options = null, string $contentType = self::contentTypes['testConnectorSmtpConnection'][0])
    {
        return $this->testConnectorSmtpConnectionAsyncWithHttpInfo($id, $create_connector_smtp_connection_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation testConnectorSmtpConnectionAsyncWithHttpInfo
     *
     * Test an inbox connector SMTP connection
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorSmtpConnectionOptions $create_connector_smtp_connection_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testConnectorSmtpConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function testConnectorSmtpConnectionAsyncWithHttpInfo($id, $create_connector_smtp_connection_options = null, string $contentType = self::contentTypes['testConnectorSmtpConnection'][0])
    {
        $returnType = '\MailSlurp\Models\ConnectorSmtpConnectionTestResult';
        $request = $this->testConnectorSmtpConnectionRequest($id, $create_connector_smtp_connection_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'testConnectorSmtpConnection'
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorSmtpConnectionOptions $create_connector_smtp_connection_options (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testConnectorSmtpConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function testConnectorSmtpConnectionRequest($id, $create_connector_smtp_connection_options = null, string $contentType = self::contentTypes['testConnectorSmtpConnection'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling testConnectorSmtpConnection'
            );
        }



        $resourcePath = '/connectors/{id}/smtp/test';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_connector_smtp_connection_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($create_connector_smtp_connection_options));
            } else {
                $httpBody = $create_connector_smtp_connection_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation testConnectorSmtpConnectionOptions
     *
     * Test an inbox connector SMTP connection options
     *
     * @param  \MailSlurp\Models\CreateConnectorSmtpConnectionOptions $create_connector_smtp_connection_options create_connector_smtp_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testConnectorSmtpConnectionOptions'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\ConnectorSmtpConnectionTestResult
     */
    public function testConnectorSmtpConnectionOptions($create_connector_smtp_connection_options, string $contentType = self::contentTypes['testConnectorSmtpConnectionOptions'][0])
    {
        list($response) = $this->testConnectorSmtpConnectionOptionsWithHttpInfo($create_connector_smtp_connection_options, $contentType);
        return $response;
    }

    /**
     * Operation testConnectorSmtpConnectionOptionsWithHttpInfo
     *
     * Test an inbox connector SMTP connection options
     *
     * @param  \MailSlurp\Models\CreateConnectorSmtpConnectionOptions $create_connector_smtp_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testConnectorSmtpConnectionOptions'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\ConnectorSmtpConnectionTestResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function testConnectorSmtpConnectionOptionsWithHttpInfo($create_connector_smtp_connection_options, string $contentType = self::contentTypes['testConnectorSmtpConnectionOptions'][0])
    {
        $request = $this->testConnectorSmtpConnectionOptionsRequest($create_connector_smtp_connection_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\ConnectorSmtpConnectionTestResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\ConnectorSmtpConnectionTestResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\ConnectorSmtpConnectionTestResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\ConnectorSmtpConnectionTestResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\ConnectorSmtpConnectionTestResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation testConnectorSmtpConnectionOptionsAsync
     *
     * Test an inbox connector SMTP connection options
     *
     * @param  \MailSlurp\Models\CreateConnectorSmtpConnectionOptions $create_connector_smtp_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testConnectorSmtpConnectionOptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function testConnectorSmtpConnectionOptionsAsync($create_connector_smtp_connection_options, string $contentType = self::contentTypes['testConnectorSmtpConnectionOptions'][0])
    {
        return $this->testConnectorSmtpConnectionOptionsAsyncWithHttpInfo($create_connector_smtp_connection_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation testConnectorSmtpConnectionOptionsAsyncWithHttpInfo
     *
     * Test an inbox connector SMTP connection options
     *
     * @param  \MailSlurp\Models\CreateConnectorSmtpConnectionOptions $create_connector_smtp_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testConnectorSmtpConnectionOptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function testConnectorSmtpConnectionOptionsAsyncWithHttpInfo($create_connector_smtp_connection_options, string $contentType = self::contentTypes['testConnectorSmtpConnectionOptions'][0])
    {
        $returnType = '\MailSlurp\Models\ConnectorSmtpConnectionTestResult';
        $request = $this->testConnectorSmtpConnectionOptionsRequest($create_connector_smtp_connection_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'testConnectorSmtpConnectionOptions'
     *
     * @param  \MailSlurp\Models\CreateConnectorSmtpConnectionOptions $create_connector_smtp_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testConnectorSmtpConnectionOptions'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function testConnectorSmtpConnectionOptionsRequest($create_connector_smtp_connection_options, string $contentType = self::contentTypes['testConnectorSmtpConnectionOptions'][0])
    {

        // verify the required parameter 'create_connector_smtp_connection_options' is set
        if ($create_connector_smtp_connection_options === null || (is_array($create_connector_smtp_connection_options) && count($create_connector_smtp_connection_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_connector_smtp_connection_options when calling testConnectorSmtpConnectionOptions'
            );
        }


        $resourcePath = '/connectors/connections/smtp/test';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_connector_smtp_connection_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($create_connector_smtp_connection_options));
            } else {
                $httpBody = $create_connector_smtp_connection_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateConnector
     *
     * Update an inbox connector
     *
     * @param  string $id id (required)
     * @param  \MailSlurp\Models\CreateConnectorOptions $create_connector_options create_connector_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateConnector'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\ConnectorDto
     */
    public function updateConnector($id, $create_connector_options, string $contentType = self::contentTypes['updateConnector'][0])
    {
        list($response) = $this->updateConnectorWithHttpInfo($id, $create_connector_options, $contentType);
        return $response;
    }

    /**
     * Operation updateConnectorWithHttpInfo
     *
     * Update an inbox connector
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorOptions $create_connector_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateConnector'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\ConnectorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateConnectorWithHttpInfo($id, $create_connector_options, string $contentType = self::contentTypes['updateConnector'][0])
    {
        $request = $this->updateConnectorRequest($id, $create_connector_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\ConnectorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\ConnectorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\ConnectorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\ConnectorDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\ConnectorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateConnectorAsync
     *
     * Update an inbox connector
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorOptions $create_connector_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateConnectorAsync($id, $create_connector_options, string $contentType = self::contentTypes['updateConnector'][0])
    {
        return $this->updateConnectorAsyncWithHttpInfo($id, $create_connector_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateConnectorAsyncWithHttpInfo
     *
     * Update an inbox connector
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorOptions $create_connector_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateConnectorAsyncWithHttpInfo($id, $create_connector_options, string $contentType = self::contentTypes['updateConnector'][0])
    {
        $returnType = '\MailSlurp\Models\ConnectorDto';
        $request = $this->updateConnectorRequest($id, $create_connector_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateConnector'
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorOptions $create_connector_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateConnector'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateConnectorRequest($id, $create_connector_options, string $contentType = self::contentTypes['updateConnector'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateConnector'
            );
        }

        // verify the required parameter 'create_connector_options' is set
        if ($create_connector_options === null || (is_array($create_connector_options) && count($create_connector_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_connector_options when calling updateConnector'
            );
        }


        $resourcePath = '/connectors/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_connector_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($create_connector_options));
            } else {
                $httpBody = $create_connector_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateConnectorImapConnection
     *
     * Update an inbox connector IMAP connection
     *
     * @param  string $id id (required)
     * @param  \MailSlurp\Models\CreateConnectorImapConnectionOptions $create_connector_imap_connection_options create_connector_imap_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateConnectorImapConnection'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\ConnectorImapConnectionDto
     */
    public function updateConnectorImapConnection($id, $create_connector_imap_connection_options, string $contentType = self::contentTypes['updateConnectorImapConnection'][0])
    {
        list($response) = $this->updateConnectorImapConnectionWithHttpInfo($id, $create_connector_imap_connection_options, $contentType);
        return $response;
    }

    /**
     * Operation updateConnectorImapConnectionWithHttpInfo
     *
     * Update an inbox connector IMAP connection
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorImapConnectionOptions $create_connector_imap_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateConnectorImapConnection'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\ConnectorImapConnectionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateConnectorImapConnectionWithHttpInfo($id, $create_connector_imap_connection_options, string $contentType = self::contentTypes['updateConnectorImapConnection'][0])
    {
        $request = $this->updateConnectorImapConnectionRequest($id, $create_connector_imap_connection_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\ConnectorImapConnectionDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\ConnectorImapConnectionDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\ConnectorImapConnectionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\ConnectorImapConnectionDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\ConnectorImapConnectionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateConnectorImapConnectionAsync
     *
     * Update an inbox connector IMAP connection
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorImapConnectionOptions $create_connector_imap_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateConnectorImapConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateConnectorImapConnectionAsync($id, $create_connector_imap_connection_options, string $contentType = self::contentTypes['updateConnectorImapConnection'][0])
    {
        return $this->updateConnectorImapConnectionAsyncWithHttpInfo($id, $create_connector_imap_connection_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateConnectorImapConnectionAsyncWithHttpInfo
     *
     * Update an inbox connector IMAP connection
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorImapConnectionOptions $create_connector_imap_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateConnectorImapConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateConnectorImapConnectionAsyncWithHttpInfo($id, $create_connector_imap_connection_options, string $contentType = self::contentTypes['updateConnectorImapConnection'][0])
    {
        $returnType = '\MailSlurp\Models\ConnectorImapConnectionDto';
        $request = $this->updateConnectorImapConnectionRequest($id, $create_connector_imap_connection_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateConnectorImapConnection'
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorImapConnectionOptions $create_connector_imap_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateConnectorImapConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateConnectorImapConnectionRequest($id, $create_connector_imap_connection_options, string $contentType = self::contentTypes['updateConnectorImapConnection'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateConnectorImapConnection'
            );
        }

        // verify the required parameter 'create_connector_imap_connection_options' is set
        if ($create_connector_imap_connection_options === null || (is_array($create_connector_imap_connection_options) && count($create_connector_imap_connection_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_connector_imap_connection_options when calling updateConnectorImapConnection'
            );
        }


        $resourcePath = '/connectors/{id}/imap';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_connector_imap_connection_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($create_connector_imap_connection_options));
            } else {
                $httpBody = $create_connector_imap_connection_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateConnectorSmtpConnection
     *
     * Update an inbox connector SMTP connection
     *
     * @param  string $id id (required)
     * @param  \MailSlurp\Models\CreateConnectorSmtpConnectionOptions $create_connector_smtp_connection_options create_connector_smtp_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateConnectorSmtpConnection'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\ConnectorSmtpConnectionDto
     */
    public function updateConnectorSmtpConnection($id, $create_connector_smtp_connection_options, string $contentType = self::contentTypes['updateConnectorSmtpConnection'][0])
    {
        list($response) = $this->updateConnectorSmtpConnectionWithHttpInfo($id, $create_connector_smtp_connection_options, $contentType);
        return $response;
    }

    /**
     * Operation updateConnectorSmtpConnectionWithHttpInfo
     *
     * Update an inbox connector SMTP connection
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorSmtpConnectionOptions $create_connector_smtp_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateConnectorSmtpConnection'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\ConnectorSmtpConnectionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateConnectorSmtpConnectionWithHttpInfo($id, $create_connector_smtp_connection_options, string $contentType = self::contentTypes['updateConnectorSmtpConnection'][0])
    {
        $request = $this->updateConnectorSmtpConnectionRequest($id, $create_connector_smtp_connection_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\ConnectorSmtpConnectionDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\ConnectorSmtpConnectionDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\ConnectorSmtpConnectionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\ConnectorSmtpConnectionDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\ConnectorSmtpConnectionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateConnectorSmtpConnectionAsync
     *
     * Update an inbox connector SMTP connection
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorSmtpConnectionOptions $create_connector_smtp_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateConnectorSmtpConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateConnectorSmtpConnectionAsync($id, $create_connector_smtp_connection_options, string $contentType = self::contentTypes['updateConnectorSmtpConnection'][0])
    {
        return $this->updateConnectorSmtpConnectionAsyncWithHttpInfo($id, $create_connector_smtp_connection_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateConnectorSmtpConnectionAsyncWithHttpInfo
     *
     * Update an inbox connector SMTP connection
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorSmtpConnectionOptions $create_connector_smtp_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateConnectorSmtpConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateConnectorSmtpConnectionAsyncWithHttpInfo($id, $create_connector_smtp_connection_options, string $contentType = self::contentTypes['updateConnectorSmtpConnection'][0])
    {
        $returnType = '\MailSlurp\Models\ConnectorSmtpConnectionDto';
        $request = $this->updateConnectorSmtpConnectionRequest($id, $create_connector_smtp_connection_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateConnectorSmtpConnection'
     *
     * @param  string $id (required)
     * @param  \MailSlurp\Models\CreateConnectorSmtpConnectionOptions $create_connector_smtp_connection_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateConnectorSmtpConnection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateConnectorSmtpConnectionRequest($id, $create_connector_smtp_connection_options, string $contentType = self::contentTypes['updateConnectorSmtpConnection'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateConnectorSmtpConnection'
            );
        }

        // verify the required parameter 'create_connector_smtp_connection_options' is set
        if ($create_connector_smtp_connection_options === null || (is_array($create_connector_smtp_connection_options) && count($create_connector_smtp_connection_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_connector_smtp_connection_options when calling updateConnectorSmtpConnection'
            );
        }


        $resourcePath = '/connectors/{id}/smtp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_connector_smtp_connection_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($create_connector_smtp_connection_options));
            } else {
                $httpBody = $create_connector_smtp_connection_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
