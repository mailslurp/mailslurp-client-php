<?php
/**
 * ToolsControllerApi
 * PHP version 7.4
 *
 * @category Class
 * @package  MailSlurp
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.2.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace MailSlurp\Apis;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use MailSlurp\ApiException;
use MailSlurp\Configuration;
use MailSlurp\HeaderSelector;
use MailSlurp\ObjectSerializer;

/**
 * ToolsControllerApi Class Doc Comment
 *
 * @category Class
 * @package  MailSlurp
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ToolsControllerApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'checkEmailFeaturesClientSupport' => [
            'application/json',
        ],
        'createNewFakeEmailAddress' => [
            'application/json',
        ],
        'generateBimiRecord' => [
            'application/json',
        ],
        'generateDmarcRecord' => [
            'application/json',
        ],
        'generateMtaStsRecord' => [
            'application/json',
        ],
        'generateTlsReportingRecord' => [
            'application/json',
        ],
        'getFakeEmailById' => [
            'application/json',
        ],
        'getFakeEmailsForAddress' => [
            'application/json',
        ],
        'lookupBimiDomain' => [
            'application/json',
        ],
        'lookupDmarcDomain' => [
            'application/json',
        ],
        'lookupMtaStsDomain' => [
            'application/json',
        ],
        'lookupTlsReportingDomain' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation checkEmailFeaturesClientSupport
     *
     * Check email client support for email HTML and CSS features
     *
     * @param  \MailSlurp\Models\CheckEmailFeaturesClientSupportOptions $check_email_features_client_support_options check_email_features_client_support_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkEmailFeaturesClientSupport'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\CheckEmailFeaturesClientSupportResults
     */
    public function checkEmailFeaturesClientSupport($check_email_features_client_support_options, string $contentType = self::contentTypes['checkEmailFeaturesClientSupport'][0])
    {
        list($response) = $this->checkEmailFeaturesClientSupportWithHttpInfo($check_email_features_client_support_options, $contentType);
        return $response;
    }

    /**
     * Operation checkEmailFeaturesClientSupportWithHttpInfo
     *
     * Check email client support for email HTML and CSS features
     *
     * @param  \MailSlurp\Models\CheckEmailFeaturesClientSupportOptions $check_email_features_client_support_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkEmailFeaturesClientSupport'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\CheckEmailFeaturesClientSupportResults, HTTP status code, HTTP response headers (array of strings)
     */
    public function checkEmailFeaturesClientSupportWithHttpInfo($check_email_features_client_support_options, string $contentType = self::contentTypes['checkEmailFeaturesClientSupport'][0])
    {
        $request = $this->checkEmailFeaturesClientSupportRequest($check_email_features_client_support_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\CheckEmailFeaturesClientSupportResults' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\CheckEmailFeaturesClientSupportResults' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\CheckEmailFeaturesClientSupportResults', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\CheckEmailFeaturesClientSupportResults';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\CheckEmailFeaturesClientSupportResults',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation checkEmailFeaturesClientSupportAsync
     *
     * Check email client support for email HTML and CSS features
     *
     * @param  \MailSlurp\Models\CheckEmailFeaturesClientSupportOptions $check_email_features_client_support_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkEmailFeaturesClientSupport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkEmailFeaturesClientSupportAsync($check_email_features_client_support_options, string $contentType = self::contentTypes['checkEmailFeaturesClientSupport'][0])
    {
        return $this->checkEmailFeaturesClientSupportAsyncWithHttpInfo($check_email_features_client_support_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation checkEmailFeaturesClientSupportAsyncWithHttpInfo
     *
     * Check email client support for email HTML and CSS features
     *
     * @param  \MailSlurp\Models\CheckEmailFeaturesClientSupportOptions $check_email_features_client_support_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkEmailFeaturesClientSupport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function checkEmailFeaturesClientSupportAsyncWithHttpInfo($check_email_features_client_support_options, string $contentType = self::contentTypes['checkEmailFeaturesClientSupport'][0])
    {
        $returnType = '\MailSlurp\Models\CheckEmailFeaturesClientSupportResults';
        $request = $this->checkEmailFeaturesClientSupportRequest($check_email_features_client_support_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'checkEmailFeaturesClientSupport'
     *
     * @param  \MailSlurp\Models\CheckEmailFeaturesClientSupportOptions $check_email_features_client_support_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['checkEmailFeaturesClientSupport'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function checkEmailFeaturesClientSupportRequest($check_email_features_client_support_options, string $contentType = self::contentTypes['checkEmailFeaturesClientSupport'][0])
    {

        // verify the required parameter 'check_email_features_client_support_options' is set
        if ($check_email_features_client_support_options === null || (is_array($check_email_features_client_support_options) && count($check_email_features_client_support_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $check_email_features_client_support_options when calling checkEmailFeaturesClientSupport'
            );
        }


        $resourcePath = '/tools/check-email-features-client-support';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($check_email_features_client_support_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($check_email_features_client_support_options));
            } else {
                $httpBody = $check_email_features_client_support_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNewFakeEmailAddress
     *
     * Create a new email address using the fake email domains
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNewFakeEmailAddress'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\NewFakeEmailAddressResult
     */
    public function createNewFakeEmailAddress(string $contentType = self::contentTypes['createNewFakeEmailAddress'][0])
    {
        list($response) = $this->createNewFakeEmailAddressWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation createNewFakeEmailAddressWithHttpInfo
     *
     * Create a new email address using the fake email domains
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNewFakeEmailAddress'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\NewFakeEmailAddressResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNewFakeEmailAddressWithHttpInfo(string $contentType = self::contentTypes['createNewFakeEmailAddress'][0])
    {
        $request = $this->createNewFakeEmailAddressRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\NewFakeEmailAddressResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\NewFakeEmailAddressResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\NewFakeEmailAddressResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\NewFakeEmailAddressResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\NewFakeEmailAddressResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNewFakeEmailAddressAsync
     *
     * Create a new email address using the fake email domains
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNewFakeEmailAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNewFakeEmailAddressAsync(string $contentType = self::contentTypes['createNewFakeEmailAddress'][0])
    {
        return $this->createNewFakeEmailAddressAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNewFakeEmailAddressAsyncWithHttpInfo
     *
     * Create a new email address using the fake email domains
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNewFakeEmailAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNewFakeEmailAddressAsyncWithHttpInfo(string $contentType = self::contentTypes['createNewFakeEmailAddress'][0])
    {
        $returnType = '\MailSlurp\Models\NewFakeEmailAddressResult';
        $request = $this->createNewFakeEmailAddressRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNewFakeEmailAddress'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNewFakeEmailAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createNewFakeEmailAddressRequest(string $contentType = self::contentTypes['createNewFakeEmailAddress'][0])
    {


        $resourcePath = '/tools/fake-email';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation generateBimiRecord
     *
     * Create a BIMI record policy
     *
     * @param  \MailSlurp\Models\GenerateBimiRecordOptions $generate_bimi_record_options generate_bimi_record_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateBimiRecord'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\GenerateBimiRecordResults
     */
    public function generateBimiRecord($generate_bimi_record_options, string $contentType = self::contentTypes['generateBimiRecord'][0])
    {
        list($response) = $this->generateBimiRecordWithHttpInfo($generate_bimi_record_options, $contentType);
        return $response;
    }

    /**
     * Operation generateBimiRecordWithHttpInfo
     *
     * Create a BIMI record policy
     *
     * @param  \MailSlurp\Models\GenerateBimiRecordOptions $generate_bimi_record_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateBimiRecord'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\GenerateBimiRecordResults, HTTP status code, HTTP response headers (array of strings)
     */
    public function generateBimiRecordWithHttpInfo($generate_bimi_record_options, string $contentType = self::contentTypes['generateBimiRecord'][0])
    {
        $request = $this->generateBimiRecordRequest($generate_bimi_record_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\GenerateBimiRecordResults' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\GenerateBimiRecordResults' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\GenerateBimiRecordResults', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\GenerateBimiRecordResults';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\GenerateBimiRecordResults',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation generateBimiRecordAsync
     *
     * Create a BIMI record policy
     *
     * @param  \MailSlurp\Models\GenerateBimiRecordOptions $generate_bimi_record_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateBimiRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateBimiRecordAsync($generate_bimi_record_options, string $contentType = self::contentTypes['generateBimiRecord'][0])
    {
        return $this->generateBimiRecordAsyncWithHttpInfo($generate_bimi_record_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation generateBimiRecordAsyncWithHttpInfo
     *
     * Create a BIMI record policy
     *
     * @param  \MailSlurp\Models\GenerateBimiRecordOptions $generate_bimi_record_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateBimiRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateBimiRecordAsyncWithHttpInfo($generate_bimi_record_options, string $contentType = self::contentTypes['generateBimiRecord'][0])
    {
        $returnType = '\MailSlurp\Models\GenerateBimiRecordResults';
        $request = $this->generateBimiRecordRequest($generate_bimi_record_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'generateBimiRecord'
     *
     * @param  \MailSlurp\Models\GenerateBimiRecordOptions $generate_bimi_record_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateBimiRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function generateBimiRecordRequest($generate_bimi_record_options, string $contentType = self::contentTypes['generateBimiRecord'][0])
    {

        // verify the required parameter 'generate_bimi_record_options' is set
        if ($generate_bimi_record_options === null || (is_array($generate_bimi_record_options) && count($generate_bimi_record_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $generate_bimi_record_options when calling generateBimiRecord'
            );
        }


        $resourcePath = '/tools/generate-bimi-record';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($generate_bimi_record_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($generate_bimi_record_options));
            } else {
                $httpBody = $generate_bimi_record_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation generateDmarcRecord
     *
     * Create a DMARC record policy
     *
     * @param  \MailSlurp\Models\GenerateDmarcRecordOptions $generate_dmarc_record_options generate_dmarc_record_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateDmarcRecord'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\GenerateDmarcRecordResults
     */
    public function generateDmarcRecord($generate_dmarc_record_options, string $contentType = self::contentTypes['generateDmarcRecord'][0])
    {
        list($response) = $this->generateDmarcRecordWithHttpInfo($generate_dmarc_record_options, $contentType);
        return $response;
    }

    /**
     * Operation generateDmarcRecordWithHttpInfo
     *
     * Create a DMARC record policy
     *
     * @param  \MailSlurp\Models\GenerateDmarcRecordOptions $generate_dmarc_record_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateDmarcRecord'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\GenerateDmarcRecordResults, HTTP status code, HTTP response headers (array of strings)
     */
    public function generateDmarcRecordWithHttpInfo($generate_dmarc_record_options, string $contentType = self::contentTypes['generateDmarcRecord'][0])
    {
        $request = $this->generateDmarcRecordRequest($generate_dmarc_record_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\GenerateDmarcRecordResults' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\GenerateDmarcRecordResults' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\GenerateDmarcRecordResults', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\GenerateDmarcRecordResults';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\GenerateDmarcRecordResults',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation generateDmarcRecordAsync
     *
     * Create a DMARC record policy
     *
     * @param  \MailSlurp\Models\GenerateDmarcRecordOptions $generate_dmarc_record_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateDmarcRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateDmarcRecordAsync($generate_dmarc_record_options, string $contentType = self::contentTypes['generateDmarcRecord'][0])
    {
        return $this->generateDmarcRecordAsyncWithHttpInfo($generate_dmarc_record_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation generateDmarcRecordAsyncWithHttpInfo
     *
     * Create a DMARC record policy
     *
     * @param  \MailSlurp\Models\GenerateDmarcRecordOptions $generate_dmarc_record_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateDmarcRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateDmarcRecordAsyncWithHttpInfo($generate_dmarc_record_options, string $contentType = self::contentTypes['generateDmarcRecord'][0])
    {
        $returnType = '\MailSlurp\Models\GenerateDmarcRecordResults';
        $request = $this->generateDmarcRecordRequest($generate_dmarc_record_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'generateDmarcRecord'
     *
     * @param  \MailSlurp\Models\GenerateDmarcRecordOptions $generate_dmarc_record_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateDmarcRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function generateDmarcRecordRequest($generate_dmarc_record_options, string $contentType = self::contentTypes['generateDmarcRecord'][0])
    {

        // verify the required parameter 'generate_dmarc_record_options' is set
        if ($generate_dmarc_record_options === null || (is_array($generate_dmarc_record_options) && count($generate_dmarc_record_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $generate_dmarc_record_options when calling generateDmarcRecord'
            );
        }


        $resourcePath = '/tools/generate-dmarc-record';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($generate_dmarc_record_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($generate_dmarc_record_options));
            } else {
                $httpBody = $generate_dmarc_record_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation generateMtaStsRecord
     *
     * Create a TLS reporting record policy
     *
     * @param  \MailSlurp\Models\GenerateMtaStsRecordOptions $generate_mta_sts_record_options generate_mta_sts_record_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateMtaStsRecord'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\GenerateMtaStsRecordResults
     */
    public function generateMtaStsRecord($generate_mta_sts_record_options, string $contentType = self::contentTypes['generateMtaStsRecord'][0])
    {
        list($response) = $this->generateMtaStsRecordWithHttpInfo($generate_mta_sts_record_options, $contentType);
        return $response;
    }

    /**
     * Operation generateMtaStsRecordWithHttpInfo
     *
     * Create a TLS reporting record policy
     *
     * @param  \MailSlurp\Models\GenerateMtaStsRecordOptions $generate_mta_sts_record_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateMtaStsRecord'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\GenerateMtaStsRecordResults, HTTP status code, HTTP response headers (array of strings)
     */
    public function generateMtaStsRecordWithHttpInfo($generate_mta_sts_record_options, string $contentType = self::contentTypes['generateMtaStsRecord'][0])
    {
        $request = $this->generateMtaStsRecordRequest($generate_mta_sts_record_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\GenerateMtaStsRecordResults' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\GenerateMtaStsRecordResults' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\GenerateMtaStsRecordResults', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\GenerateMtaStsRecordResults';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\GenerateMtaStsRecordResults',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation generateMtaStsRecordAsync
     *
     * Create a TLS reporting record policy
     *
     * @param  \MailSlurp\Models\GenerateMtaStsRecordOptions $generate_mta_sts_record_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateMtaStsRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateMtaStsRecordAsync($generate_mta_sts_record_options, string $contentType = self::contentTypes['generateMtaStsRecord'][0])
    {
        return $this->generateMtaStsRecordAsyncWithHttpInfo($generate_mta_sts_record_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation generateMtaStsRecordAsyncWithHttpInfo
     *
     * Create a TLS reporting record policy
     *
     * @param  \MailSlurp\Models\GenerateMtaStsRecordOptions $generate_mta_sts_record_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateMtaStsRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateMtaStsRecordAsyncWithHttpInfo($generate_mta_sts_record_options, string $contentType = self::contentTypes['generateMtaStsRecord'][0])
    {
        $returnType = '\MailSlurp\Models\GenerateMtaStsRecordResults';
        $request = $this->generateMtaStsRecordRequest($generate_mta_sts_record_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'generateMtaStsRecord'
     *
     * @param  \MailSlurp\Models\GenerateMtaStsRecordOptions $generate_mta_sts_record_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateMtaStsRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function generateMtaStsRecordRequest($generate_mta_sts_record_options, string $contentType = self::contentTypes['generateMtaStsRecord'][0])
    {

        // verify the required parameter 'generate_mta_sts_record_options' is set
        if ($generate_mta_sts_record_options === null || (is_array($generate_mta_sts_record_options) && count($generate_mta_sts_record_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $generate_mta_sts_record_options when calling generateMtaStsRecord'
            );
        }


        $resourcePath = '/tools/generate-mta-sts-record';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($generate_mta_sts_record_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($generate_mta_sts_record_options));
            } else {
                $httpBody = $generate_mta_sts_record_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation generateTlsReportingRecord
     *
     * Create a TLS reporting record policy
     *
     * @param  \MailSlurp\Models\GenerateTlsReportingRecordOptions $generate_tls_reporting_record_options generate_tls_reporting_record_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateTlsReportingRecord'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\GenerateTlsReportingRecordResults
     */
    public function generateTlsReportingRecord($generate_tls_reporting_record_options, string $contentType = self::contentTypes['generateTlsReportingRecord'][0])
    {
        list($response) = $this->generateTlsReportingRecordWithHttpInfo($generate_tls_reporting_record_options, $contentType);
        return $response;
    }

    /**
     * Operation generateTlsReportingRecordWithHttpInfo
     *
     * Create a TLS reporting record policy
     *
     * @param  \MailSlurp\Models\GenerateTlsReportingRecordOptions $generate_tls_reporting_record_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateTlsReportingRecord'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\GenerateTlsReportingRecordResults, HTTP status code, HTTP response headers (array of strings)
     */
    public function generateTlsReportingRecordWithHttpInfo($generate_tls_reporting_record_options, string $contentType = self::contentTypes['generateTlsReportingRecord'][0])
    {
        $request = $this->generateTlsReportingRecordRequest($generate_tls_reporting_record_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\GenerateTlsReportingRecordResults' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\GenerateTlsReportingRecordResults' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\GenerateTlsReportingRecordResults', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\GenerateTlsReportingRecordResults';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\GenerateTlsReportingRecordResults',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation generateTlsReportingRecordAsync
     *
     * Create a TLS reporting record policy
     *
     * @param  \MailSlurp\Models\GenerateTlsReportingRecordOptions $generate_tls_reporting_record_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateTlsReportingRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateTlsReportingRecordAsync($generate_tls_reporting_record_options, string $contentType = self::contentTypes['generateTlsReportingRecord'][0])
    {
        return $this->generateTlsReportingRecordAsyncWithHttpInfo($generate_tls_reporting_record_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation generateTlsReportingRecordAsyncWithHttpInfo
     *
     * Create a TLS reporting record policy
     *
     * @param  \MailSlurp\Models\GenerateTlsReportingRecordOptions $generate_tls_reporting_record_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateTlsReportingRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateTlsReportingRecordAsyncWithHttpInfo($generate_tls_reporting_record_options, string $contentType = self::contentTypes['generateTlsReportingRecord'][0])
    {
        $returnType = '\MailSlurp\Models\GenerateTlsReportingRecordResults';
        $request = $this->generateTlsReportingRecordRequest($generate_tls_reporting_record_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'generateTlsReportingRecord'
     *
     * @param  \MailSlurp\Models\GenerateTlsReportingRecordOptions $generate_tls_reporting_record_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['generateTlsReportingRecord'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function generateTlsReportingRecordRequest($generate_tls_reporting_record_options, string $contentType = self::contentTypes['generateTlsReportingRecord'][0])
    {

        // verify the required parameter 'generate_tls_reporting_record_options' is set
        if ($generate_tls_reporting_record_options === null || (is_array($generate_tls_reporting_record_options) && count($generate_tls_reporting_record_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $generate_tls_reporting_record_options when calling generateTlsReportingRecord'
            );
        }


        $resourcePath = '/tools/generate-tls-reporting-record';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($generate_tls_reporting_record_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($generate_tls_reporting_record_options));
            } else {
                $httpBody = $generate_tls_reporting_record_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFakeEmailById
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFakeEmailById'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\FakeEmailResult
     */
    public function getFakeEmailById($id, string $contentType = self::contentTypes['getFakeEmailById'][0])
    {
        list($response) = $this->getFakeEmailByIdWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getFakeEmailByIdWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFakeEmailById'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\FakeEmailResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFakeEmailByIdWithHttpInfo($id, string $contentType = self::contentTypes['getFakeEmailById'][0])
    {
        $request = $this->getFakeEmailByIdRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\FakeEmailResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\FakeEmailResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\FakeEmailResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\FakeEmailResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\FakeEmailResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFakeEmailByIdAsync
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFakeEmailById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFakeEmailByIdAsync($id, string $contentType = self::contentTypes['getFakeEmailById'][0])
    {
        return $this->getFakeEmailByIdAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFakeEmailByIdAsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFakeEmailById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFakeEmailByIdAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getFakeEmailById'][0])
    {
        $returnType = '\MailSlurp\Models\FakeEmailResult';
        $request = $this->getFakeEmailByIdRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFakeEmailById'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFakeEmailById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFakeEmailByIdRequest($id, string $contentType = self::contentTypes['getFakeEmailById'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getFakeEmailById'
            );
        }


        $resourcePath = '/tools/fake-email';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFakeEmailsForAddress
     *
     * @param  string $email_address email_address (required)
     * @param  int $page page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFakeEmailsForAddress'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\FakeEmailPreview[]
     */
    public function getFakeEmailsForAddress($email_address, $page = null, string $contentType = self::contentTypes['getFakeEmailsForAddress'][0])
    {
        list($response) = $this->getFakeEmailsForAddressWithHttpInfo($email_address, $page, $contentType);
        return $response;
    }

    /**
     * Operation getFakeEmailsForAddressWithHttpInfo
     *
     * @param  string $email_address (required)
     * @param  int $page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFakeEmailsForAddress'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\FakeEmailPreview[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getFakeEmailsForAddressWithHttpInfo($email_address, $page = null, string $contentType = self::contentTypes['getFakeEmailsForAddress'][0])
    {
        $request = $this->getFakeEmailsForAddressRequest($email_address, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\FakeEmailPreview[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\FakeEmailPreview[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\FakeEmailPreview[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\FakeEmailPreview[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\FakeEmailPreview[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFakeEmailsForAddressAsync
     *
     * @param  string $email_address (required)
     * @param  int $page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFakeEmailsForAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFakeEmailsForAddressAsync($email_address, $page = null, string $contentType = self::contentTypes['getFakeEmailsForAddress'][0])
    {
        return $this->getFakeEmailsForAddressAsyncWithHttpInfo($email_address, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFakeEmailsForAddressAsyncWithHttpInfo
     *
     * @param  string $email_address (required)
     * @param  int $page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFakeEmailsForAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFakeEmailsForAddressAsyncWithHttpInfo($email_address, $page = null, string $contentType = self::contentTypes['getFakeEmailsForAddress'][0])
    {
        $returnType = '\MailSlurp\Models\FakeEmailPreview[]';
        $request = $this->getFakeEmailsForAddressRequest($email_address, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFakeEmailsForAddress'
     *
     * @param  string $email_address (required)
     * @param  int $page (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getFakeEmailsForAddress'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFakeEmailsForAddressRequest($email_address, $page = null, string $contentType = self::contentTypes['getFakeEmailsForAddress'][0])
    {

        // verify the required parameter 'email_address' is set
        if ($email_address === null || (is_array($email_address) && count($email_address) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $email_address when calling getFakeEmailsForAddress'
            );
        }



        $resourcePath = '/tools/fake-emails';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email_address,
            'emailAddress', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lookupBimiDomain
     *
     * Lookup a BIMI record policy
     *
     * @param  \MailSlurp\Models\LookupBimiDomainOptions $lookup_bimi_domain_options lookup_bimi_domain_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lookupBimiDomain'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\LookupBimiDomainResults
     */
    public function lookupBimiDomain($lookup_bimi_domain_options, string $contentType = self::contentTypes['lookupBimiDomain'][0])
    {
        list($response) = $this->lookupBimiDomainWithHttpInfo($lookup_bimi_domain_options, $contentType);
        return $response;
    }

    /**
     * Operation lookupBimiDomainWithHttpInfo
     *
     * Lookup a BIMI record policy
     *
     * @param  \MailSlurp\Models\LookupBimiDomainOptions $lookup_bimi_domain_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lookupBimiDomain'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\LookupBimiDomainResults, HTTP status code, HTTP response headers (array of strings)
     */
    public function lookupBimiDomainWithHttpInfo($lookup_bimi_domain_options, string $contentType = self::contentTypes['lookupBimiDomain'][0])
    {
        $request = $this->lookupBimiDomainRequest($lookup_bimi_domain_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\LookupBimiDomainResults' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\LookupBimiDomainResults' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\LookupBimiDomainResults', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\LookupBimiDomainResults';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\LookupBimiDomainResults',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation lookupBimiDomainAsync
     *
     * Lookup a BIMI record policy
     *
     * @param  \MailSlurp\Models\LookupBimiDomainOptions $lookup_bimi_domain_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lookupBimiDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lookupBimiDomainAsync($lookup_bimi_domain_options, string $contentType = self::contentTypes['lookupBimiDomain'][0])
    {
        return $this->lookupBimiDomainAsyncWithHttpInfo($lookup_bimi_domain_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation lookupBimiDomainAsyncWithHttpInfo
     *
     * Lookup a BIMI record policy
     *
     * @param  \MailSlurp\Models\LookupBimiDomainOptions $lookup_bimi_domain_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lookupBimiDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lookupBimiDomainAsyncWithHttpInfo($lookup_bimi_domain_options, string $contentType = self::contentTypes['lookupBimiDomain'][0])
    {
        $returnType = '\MailSlurp\Models\LookupBimiDomainResults';
        $request = $this->lookupBimiDomainRequest($lookup_bimi_domain_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'lookupBimiDomain'
     *
     * @param  \MailSlurp\Models\LookupBimiDomainOptions $lookup_bimi_domain_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lookupBimiDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function lookupBimiDomainRequest($lookup_bimi_domain_options, string $contentType = self::contentTypes['lookupBimiDomain'][0])
    {

        // verify the required parameter 'lookup_bimi_domain_options' is set
        if ($lookup_bimi_domain_options === null || (is_array($lookup_bimi_domain_options) && count($lookup_bimi_domain_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lookup_bimi_domain_options when calling lookupBimiDomain'
            );
        }


        $resourcePath = '/tools/lookup-bimi-domain';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($lookup_bimi_domain_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($lookup_bimi_domain_options));
            } else {
                $httpBody = $lookup_bimi_domain_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lookupDmarcDomain
     *
     * Lookup a DMARC record policy
     *
     * @param  \MailSlurp\Models\LookupDmarcDomainOptions $lookup_dmarc_domain_options lookup_dmarc_domain_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lookupDmarcDomain'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\LookupDmarcDomainResults
     */
    public function lookupDmarcDomain($lookup_dmarc_domain_options, string $contentType = self::contentTypes['lookupDmarcDomain'][0])
    {
        list($response) = $this->lookupDmarcDomainWithHttpInfo($lookup_dmarc_domain_options, $contentType);
        return $response;
    }

    /**
     * Operation lookupDmarcDomainWithHttpInfo
     *
     * Lookup a DMARC record policy
     *
     * @param  \MailSlurp\Models\LookupDmarcDomainOptions $lookup_dmarc_domain_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lookupDmarcDomain'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\LookupDmarcDomainResults, HTTP status code, HTTP response headers (array of strings)
     */
    public function lookupDmarcDomainWithHttpInfo($lookup_dmarc_domain_options, string $contentType = self::contentTypes['lookupDmarcDomain'][0])
    {
        $request = $this->lookupDmarcDomainRequest($lookup_dmarc_domain_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\LookupDmarcDomainResults' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\LookupDmarcDomainResults' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\LookupDmarcDomainResults', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\LookupDmarcDomainResults';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\LookupDmarcDomainResults',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation lookupDmarcDomainAsync
     *
     * Lookup a DMARC record policy
     *
     * @param  \MailSlurp\Models\LookupDmarcDomainOptions $lookup_dmarc_domain_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lookupDmarcDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lookupDmarcDomainAsync($lookup_dmarc_domain_options, string $contentType = self::contentTypes['lookupDmarcDomain'][0])
    {
        return $this->lookupDmarcDomainAsyncWithHttpInfo($lookup_dmarc_domain_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation lookupDmarcDomainAsyncWithHttpInfo
     *
     * Lookup a DMARC record policy
     *
     * @param  \MailSlurp\Models\LookupDmarcDomainOptions $lookup_dmarc_domain_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lookupDmarcDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lookupDmarcDomainAsyncWithHttpInfo($lookup_dmarc_domain_options, string $contentType = self::contentTypes['lookupDmarcDomain'][0])
    {
        $returnType = '\MailSlurp\Models\LookupDmarcDomainResults';
        $request = $this->lookupDmarcDomainRequest($lookup_dmarc_domain_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'lookupDmarcDomain'
     *
     * @param  \MailSlurp\Models\LookupDmarcDomainOptions $lookup_dmarc_domain_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lookupDmarcDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function lookupDmarcDomainRequest($lookup_dmarc_domain_options, string $contentType = self::contentTypes['lookupDmarcDomain'][0])
    {

        // verify the required parameter 'lookup_dmarc_domain_options' is set
        if ($lookup_dmarc_domain_options === null || (is_array($lookup_dmarc_domain_options) && count($lookup_dmarc_domain_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lookup_dmarc_domain_options when calling lookupDmarcDomain'
            );
        }


        $resourcePath = '/tools/lookup-dmarc-domain';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($lookup_dmarc_domain_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($lookup_dmarc_domain_options));
            } else {
                $httpBody = $lookup_dmarc_domain_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lookupMtaStsDomain
     *
     * Lookup a MTA-STS domain policy
     *
     * @param  \MailSlurp\Models\LookupMtaStsDomainOptions $lookup_mta_sts_domain_options lookup_mta_sts_domain_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lookupMtaStsDomain'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\LookupMtaStsDomainResults
     */
    public function lookupMtaStsDomain($lookup_mta_sts_domain_options, string $contentType = self::contentTypes['lookupMtaStsDomain'][0])
    {
        list($response) = $this->lookupMtaStsDomainWithHttpInfo($lookup_mta_sts_domain_options, $contentType);
        return $response;
    }

    /**
     * Operation lookupMtaStsDomainWithHttpInfo
     *
     * Lookup a MTA-STS domain policy
     *
     * @param  \MailSlurp\Models\LookupMtaStsDomainOptions $lookup_mta_sts_domain_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lookupMtaStsDomain'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\LookupMtaStsDomainResults, HTTP status code, HTTP response headers (array of strings)
     */
    public function lookupMtaStsDomainWithHttpInfo($lookup_mta_sts_domain_options, string $contentType = self::contentTypes['lookupMtaStsDomain'][0])
    {
        $request = $this->lookupMtaStsDomainRequest($lookup_mta_sts_domain_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\LookupMtaStsDomainResults' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\LookupMtaStsDomainResults' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\LookupMtaStsDomainResults', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\LookupMtaStsDomainResults';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\LookupMtaStsDomainResults',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation lookupMtaStsDomainAsync
     *
     * Lookup a MTA-STS domain policy
     *
     * @param  \MailSlurp\Models\LookupMtaStsDomainOptions $lookup_mta_sts_domain_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lookupMtaStsDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lookupMtaStsDomainAsync($lookup_mta_sts_domain_options, string $contentType = self::contentTypes['lookupMtaStsDomain'][0])
    {
        return $this->lookupMtaStsDomainAsyncWithHttpInfo($lookup_mta_sts_domain_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation lookupMtaStsDomainAsyncWithHttpInfo
     *
     * Lookup a MTA-STS domain policy
     *
     * @param  \MailSlurp\Models\LookupMtaStsDomainOptions $lookup_mta_sts_domain_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lookupMtaStsDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lookupMtaStsDomainAsyncWithHttpInfo($lookup_mta_sts_domain_options, string $contentType = self::contentTypes['lookupMtaStsDomain'][0])
    {
        $returnType = '\MailSlurp\Models\LookupMtaStsDomainResults';
        $request = $this->lookupMtaStsDomainRequest($lookup_mta_sts_domain_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'lookupMtaStsDomain'
     *
     * @param  \MailSlurp\Models\LookupMtaStsDomainOptions $lookup_mta_sts_domain_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lookupMtaStsDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function lookupMtaStsDomainRequest($lookup_mta_sts_domain_options, string $contentType = self::contentTypes['lookupMtaStsDomain'][0])
    {

        // verify the required parameter 'lookup_mta_sts_domain_options' is set
        if ($lookup_mta_sts_domain_options === null || (is_array($lookup_mta_sts_domain_options) && count($lookup_mta_sts_domain_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lookup_mta_sts_domain_options when calling lookupMtaStsDomain'
            );
        }


        $resourcePath = '/tools/lookup-mta-sts-domain';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($lookup_mta_sts_domain_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($lookup_mta_sts_domain_options));
            } else {
                $httpBody = $lookup_mta_sts_domain_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lookupTlsReportingDomain
     *
     * Lookup a TLS reporting domain policy
     *
     * @param  \MailSlurp\Models\LookupTlsReportingDomainOptions $lookup_tls_reporting_domain_options lookup_tls_reporting_domain_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lookupTlsReportingDomain'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\LookupTlsReportingDomainResults
     */
    public function lookupTlsReportingDomain($lookup_tls_reporting_domain_options, string $contentType = self::contentTypes['lookupTlsReportingDomain'][0])
    {
        list($response) = $this->lookupTlsReportingDomainWithHttpInfo($lookup_tls_reporting_domain_options, $contentType);
        return $response;
    }

    /**
     * Operation lookupTlsReportingDomainWithHttpInfo
     *
     * Lookup a TLS reporting domain policy
     *
     * @param  \MailSlurp\Models\LookupTlsReportingDomainOptions $lookup_tls_reporting_domain_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lookupTlsReportingDomain'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\LookupTlsReportingDomainResults, HTTP status code, HTTP response headers (array of strings)
     */
    public function lookupTlsReportingDomainWithHttpInfo($lookup_tls_reporting_domain_options, string $contentType = self::contentTypes['lookupTlsReportingDomain'][0])
    {
        $request = $this->lookupTlsReportingDomainRequest($lookup_tls_reporting_domain_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\LookupTlsReportingDomainResults' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\LookupTlsReportingDomainResults' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\LookupTlsReportingDomainResults', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\LookupTlsReportingDomainResults';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\LookupTlsReportingDomainResults',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation lookupTlsReportingDomainAsync
     *
     * Lookup a TLS reporting domain policy
     *
     * @param  \MailSlurp\Models\LookupTlsReportingDomainOptions $lookup_tls_reporting_domain_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lookupTlsReportingDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lookupTlsReportingDomainAsync($lookup_tls_reporting_domain_options, string $contentType = self::contentTypes['lookupTlsReportingDomain'][0])
    {
        return $this->lookupTlsReportingDomainAsyncWithHttpInfo($lookup_tls_reporting_domain_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation lookupTlsReportingDomainAsyncWithHttpInfo
     *
     * Lookup a TLS reporting domain policy
     *
     * @param  \MailSlurp\Models\LookupTlsReportingDomainOptions $lookup_tls_reporting_domain_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lookupTlsReportingDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lookupTlsReportingDomainAsyncWithHttpInfo($lookup_tls_reporting_domain_options, string $contentType = self::contentTypes['lookupTlsReportingDomain'][0])
    {
        $returnType = '\MailSlurp\Models\LookupTlsReportingDomainResults';
        $request = $this->lookupTlsReportingDomainRequest($lookup_tls_reporting_domain_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'lookupTlsReportingDomain'
     *
     * @param  \MailSlurp\Models\LookupTlsReportingDomainOptions $lookup_tls_reporting_domain_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lookupTlsReportingDomain'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function lookupTlsReportingDomainRequest($lookup_tls_reporting_domain_options, string $contentType = self::contentTypes['lookupTlsReportingDomain'][0])
    {

        // verify the required parameter 'lookup_tls_reporting_domain_options' is set
        if ($lookup_tls_reporting_domain_options === null || (is_array($lookup_tls_reporting_domain_options) && count($lookup_tls_reporting_domain_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $lookup_tls_reporting_domain_options when calling lookupTlsReportingDomain'
            );
        }


        $resourcePath = '/tools/lookup-tls-reporting-domain';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($lookup_tls_reporting_domain_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($lookup_tls_reporting_domain_options));
            } else {
                $httpBody = $lookup_tls_reporting_domain_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
