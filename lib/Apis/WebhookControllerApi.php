<?php
/**
 * WebhookControllerApi
 * PHP version 7.4
 *
 * @category Class
 * @package  MailSlurp
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.2.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace MailSlurp\Apis;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use MailSlurp\ApiException;
use MailSlurp\Configuration;
use MailSlurp\HeaderSelector;
use MailSlurp\ObjectSerializer;

/**
 * WebhookControllerApi Class Doc Comment
 *
 * @category Class
 * @package  MailSlurp
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class WebhookControllerApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'createAccountWebhook' => [
            'application/json',
        ],
        'createWebhook' => [
            'application/json',
        ],
        'createWebhookForPhoneNumber' => [
            'application/json',
        ],
        'deleteAllWebhooks' => [
            'application/json',
        ],
        'deleteWebhook' => [
            'application/json',
        ],
        'deleteWebhookById' => [
            'application/json',
        ],
        'getAllAccountWebhooks' => [
            'application/json',
        ],
        'getAllWebhookResults' => [
            'application/json',
        ],
        'getAllWebhooks' => [
            'application/json',
        ],
        'getInboxWebhooksPaginated' => [
            'application/json',
        ],
        'getJsonSchemaForWebhookEvent' => [
            'application/json',
        ],
        'getJsonSchemaForWebhookPayload' => [
            'application/json',
        ],
        'getPhoneNumberWebhooksPaginated' => [
            'application/json',
        ],
        'getTestWebhookPayload' => [
            'application/json',
        ],
        'getTestWebhookPayloadBounce' => [
            'application/json',
        ],
        'getTestWebhookPayloadBounceRecipient' => [
            'application/json',
        ],
        'getTestWebhookPayloadDeliveryStatus' => [
            'application/json',
        ],
        'getTestWebhookPayloadEmailOpened' => [
            'application/json',
        ],
        'getTestWebhookPayloadEmailRead' => [
            'application/json',
        ],
        'getTestWebhookPayloadForWebhook' => [
            'application/json',
        ],
        'getTestWebhookPayloadNewAttachment' => [
            'application/json',
        ],
        'getTestWebhookPayloadNewContact' => [
            'application/json',
        ],
        'getTestWebhookPayloadNewEmail' => [
            'application/json',
        ],
        'getTestWebhookPayloadNewSms' => [
            'application/json',
        ],
        'getWebhook' => [
            'application/json',
        ],
        'getWebhookResult' => [
            'application/json',
        ],
        'getWebhookResults' => [
            'application/json',
        ],
        'getWebhookResultsCount' => [
            'application/json',
        ],
        'getWebhookResultsUnseenErrorCount' => [
            'application/json',
        ],
        'getWebhooks' => [
            'application/json',
        ],
        'redriveAllWebhookResults' => [
            'application/json',
        ],
        'redriveWebhookResult' => [
            'application/json',
        ],
        'sendTestData' => [
            'application/json',
        ],
        'updateWebhookHeaders' => [
            'application/json',
        ],
        'verifyWebhookSignature' => [
            'application/json',
        ],
        'waitForWebhookResults' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createAccountWebhook
     *
     * Attach a WebHook URL to an inbox
     *
     * @param  \MailSlurp\Models\CreateWebhookOptions $create_webhook_options create_webhook_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAccountWebhook'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\WebhookDto
     */
    public function createAccountWebhook($create_webhook_options, string $contentType = self::contentTypes['createAccountWebhook'][0])
    {
        list($response) = $this->createAccountWebhookWithHttpInfo($create_webhook_options, $contentType);
        return $response;
    }

    /**
     * Operation createAccountWebhookWithHttpInfo
     *
     * Attach a WebHook URL to an inbox
     *
     * @param  \MailSlurp\Models\CreateWebhookOptions $create_webhook_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAccountWebhook'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\WebhookDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAccountWebhookWithHttpInfo($create_webhook_options, string $contentType = self::contentTypes['createAccountWebhook'][0])
    {
        $request = $this->createAccountWebhookRequest($create_webhook_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\MailSlurp\Models\WebhookDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\WebhookDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\WebhookDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\WebhookDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\WebhookDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAccountWebhookAsync
     *
     * Attach a WebHook URL to an inbox
     *
     * @param  \MailSlurp\Models\CreateWebhookOptions $create_webhook_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAccountWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAccountWebhookAsync($create_webhook_options, string $contentType = self::contentTypes['createAccountWebhook'][0])
    {
        return $this->createAccountWebhookAsyncWithHttpInfo($create_webhook_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAccountWebhookAsyncWithHttpInfo
     *
     * Attach a WebHook URL to an inbox
     *
     * @param  \MailSlurp\Models\CreateWebhookOptions $create_webhook_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAccountWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAccountWebhookAsyncWithHttpInfo($create_webhook_options, string $contentType = self::contentTypes['createAccountWebhook'][0])
    {
        $returnType = '\MailSlurp\Models\WebhookDto';
        $request = $this->createAccountWebhookRequest($create_webhook_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAccountWebhook'
     *
     * @param  \MailSlurp\Models\CreateWebhookOptions $create_webhook_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createAccountWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createAccountWebhookRequest($create_webhook_options, string $contentType = self::contentTypes['createAccountWebhook'][0])
    {

        // verify the required parameter 'create_webhook_options' is set
        if ($create_webhook_options === null || (is_array($create_webhook_options) && count($create_webhook_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_webhook_options when calling createAccountWebhook'
            );
        }


        $resourcePath = '/webhooks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_webhook_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($create_webhook_options));
            } else {
                $httpBody = $create_webhook_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createWebhook
     *
     * Attach a WebHook URL to an inbox
     *
     * @param  string $inbox_id inbox_id (required)
     * @param  \MailSlurp\Models\CreateWebhookOptions $create_webhook_options create_webhook_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWebhook'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\WebhookDto
     */
    public function createWebhook($inbox_id, $create_webhook_options, string $contentType = self::contentTypes['createWebhook'][0])
    {
        list($response) = $this->createWebhookWithHttpInfo($inbox_id, $create_webhook_options, $contentType);
        return $response;
    }

    /**
     * Operation createWebhookWithHttpInfo
     *
     * Attach a WebHook URL to an inbox
     *
     * @param  string $inbox_id (required)
     * @param  \MailSlurp\Models\CreateWebhookOptions $create_webhook_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWebhook'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\WebhookDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function createWebhookWithHttpInfo($inbox_id, $create_webhook_options, string $contentType = self::contentTypes['createWebhook'][0])
    {
        $request = $this->createWebhookRequest($inbox_id, $create_webhook_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\MailSlurp\Models\WebhookDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\WebhookDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\WebhookDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\WebhookDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\WebhookDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createWebhookAsync
     *
     * Attach a WebHook URL to an inbox
     *
     * @param  string $inbox_id (required)
     * @param  \MailSlurp\Models\CreateWebhookOptions $create_webhook_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createWebhookAsync($inbox_id, $create_webhook_options, string $contentType = self::contentTypes['createWebhook'][0])
    {
        return $this->createWebhookAsyncWithHttpInfo($inbox_id, $create_webhook_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createWebhookAsyncWithHttpInfo
     *
     * Attach a WebHook URL to an inbox
     *
     * @param  string $inbox_id (required)
     * @param  \MailSlurp\Models\CreateWebhookOptions $create_webhook_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createWebhookAsyncWithHttpInfo($inbox_id, $create_webhook_options, string $contentType = self::contentTypes['createWebhook'][0])
    {
        $returnType = '\MailSlurp\Models\WebhookDto';
        $request = $this->createWebhookRequest($inbox_id, $create_webhook_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createWebhook'
     *
     * @param  string $inbox_id (required)
     * @param  \MailSlurp\Models\CreateWebhookOptions $create_webhook_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createWebhookRequest($inbox_id, $create_webhook_options, string $contentType = self::contentTypes['createWebhook'][0])
    {

        // verify the required parameter 'inbox_id' is set
        if ($inbox_id === null || (is_array($inbox_id) && count($inbox_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inbox_id when calling createWebhook'
            );
        }

        // verify the required parameter 'create_webhook_options' is set
        if ($create_webhook_options === null || (is_array($create_webhook_options) && count($create_webhook_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_webhook_options when calling createWebhook'
            );
        }


        $resourcePath = '/inboxes/{inboxId}/webhooks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($inbox_id !== null) {
            $resourcePath = str_replace(
                '{' . 'inboxId' . '}',
                ObjectSerializer::toPathValue($inbox_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_webhook_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($create_webhook_options));
            } else {
                $httpBody = $create_webhook_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createWebhookForPhoneNumber
     *
     * Attach a WebHook URL to a phone number
     *
     * @param  string $phone_number_id phone_number_id (required)
     * @param  \MailSlurp\Models\CreateWebhookOptions $create_webhook_options create_webhook_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWebhookForPhoneNumber'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\WebhookDto
     */
    public function createWebhookForPhoneNumber($phone_number_id, $create_webhook_options, string $contentType = self::contentTypes['createWebhookForPhoneNumber'][0])
    {
        list($response) = $this->createWebhookForPhoneNumberWithHttpInfo($phone_number_id, $create_webhook_options, $contentType);
        return $response;
    }

    /**
     * Operation createWebhookForPhoneNumberWithHttpInfo
     *
     * Attach a WebHook URL to a phone number
     *
     * @param  string $phone_number_id (required)
     * @param  \MailSlurp\Models\CreateWebhookOptions $create_webhook_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWebhookForPhoneNumber'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\WebhookDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function createWebhookForPhoneNumberWithHttpInfo($phone_number_id, $create_webhook_options, string $contentType = self::contentTypes['createWebhookForPhoneNumber'][0])
    {
        $request = $this->createWebhookForPhoneNumberRequest($phone_number_id, $create_webhook_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\MailSlurp\Models\WebhookDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\WebhookDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\WebhookDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\WebhookDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\WebhookDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createWebhookForPhoneNumberAsync
     *
     * Attach a WebHook URL to a phone number
     *
     * @param  string $phone_number_id (required)
     * @param  \MailSlurp\Models\CreateWebhookOptions $create_webhook_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWebhookForPhoneNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createWebhookForPhoneNumberAsync($phone_number_id, $create_webhook_options, string $contentType = self::contentTypes['createWebhookForPhoneNumber'][0])
    {
        return $this->createWebhookForPhoneNumberAsyncWithHttpInfo($phone_number_id, $create_webhook_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createWebhookForPhoneNumberAsyncWithHttpInfo
     *
     * Attach a WebHook URL to a phone number
     *
     * @param  string $phone_number_id (required)
     * @param  \MailSlurp\Models\CreateWebhookOptions $create_webhook_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWebhookForPhoneNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createWebhookForPhoneNumberAsyncWithHttpInfo($phone_number_id, $create_webhook_options, string $contentType = self::contentTypes['createWebhookForPhoneNumber'][0])
    {
        $returnType = '\MailSlurp\Models\WebhookDto';
        $request = $this->createWebhookForPhoneNumberRequest($phone_number_id, $create_webhook_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createWebhookForPhoneNumber'
     *
     * @param  string $phone_number_id (required)
     * @param  \MailSlurp\Models\CreateWebhookOptions $create_webhook_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createWebhookForPhoneNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createWebhookForPhoneNumberRequest($phone_number_id, $create_webhook_options, string $contentType = self::contentTypes['createWebhookForPhoneNumber'][0])
    {

        // verify the required parameter 'phone_number_id' is set
        if ($phone_number_id === null || (is_array($phone_number_id) && count($phone_number_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $phone_number_id when calling createWebhookForPhoneNumber'
            );
        }

        // verify the required parameter 'create_webhook_options' is set
        if ($create_webhook_options === null || (is_array($create_webhook_options) && count($create_webhook_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_webhook_options when calling createWebhookForPhoneNumber'
            );
        }


        $resourcePath = '/phone/numbers/{phoneNumberId}/webhooks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($phone_number_id !== null) {
            $resourcePath = str_replace(
                '{' . 'phoneNumberId' . '}',
                ObjectSerializer::toPathValue($phone_number_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_webhook_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($create_webhook_options));
            } else {
                $httpBody = $create_webhook_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteAllWebhooks
     *
     * Delete all webhooks
     *
     * @param  \DateTime $before before (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllWebhooks'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteAllWebhooks($before = null, string $contentType = self::contentTypes['deleteAllWebhooks'][0])
    {
        $this->deleteAllWebhooksWithHttpInfo($before, $contentType);
    }

    /**
     * Operation deleteAllWebhooksWithHttpInfo
     *
     * Delete all webhooks
     *
     * @param  \DateTime $before before (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllWebhooks'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteAllWebhooksWithHttpInfo($before = null, string $contentType = self::contentTypes['deleteAllWebhooks'][0])
    {
        $request = $this->deleteAllWebhooksRequest($before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteAllWebhooksAsync
     *
     * Delete all webhooks
     *
     * @param  \DateTime $before before (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllWebhooks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAllWebhooksAsync($before = null, string $contentType = self::contentTypes['deleteAllWebhooks'][0])
    {
        return $this->deleteAllWebhooksAsyncWithHttpInfo($before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteAllWebhooksAsyncWithHttpInfo
     *
     * Delete all webhooks
     *
     * @param  \DateTime $before before (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllWebhooks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteAllWebhooksAsyncWithHttpInfo($before = null, string $contentType = self::contentTypes['deleteAllWebhooks'][0])
    {
        $returnType = '';
        $request = $this->deleteAllWebhooksRequest($before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteAllWebhooks'
     *
     * @param  \DateTime $before before (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteAllWebhooks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteAllWebhooksRequest($before = null, string $contentType = self::contentTypes['deleteAllWebhooks'][0])
    {



        $resourcePath = '/webhooks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $before,
            'before', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteWebhook
     *
     * Delete and disable a Webhook for an Inbox
     *
     * @param  string $inbox_id inbox_id (required)
     * @param  string $webhook_id webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhook'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteWebhook($inbox_id, $webhook_id, string $contentType = self::contentTypes['deleteWebhook'][0])
    {
        $this->deleteWebhookWithHttpInfo($inbox_id, $webhook_id, $contentType);
    }

    /**
     * Operation deleteWebhookWithHttpInfo
     *
     * Delete and disable a Webhook for an Inbox
     *
     * @param  string $inbox_id (required)
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhook'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteWebhookWithHttpInfo($inbox_id, $webhook_id, string $contentType = self::contentTypes['deleteWebhook'][0])
    {
        $request = $this->deleteWebhookRequest($inbox_id, $webhook_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteWebhookAsync
     *
     * Delete and disable a Webhook for an Inbox
     *
     * @param  string $inbox_id (required)
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteWebhookAsync($inbox_id, $webhook_id, string $contentType = self::contentTypes['deleteWebhook'][0])
    {
        return $this->deleteWebhookAsyncWithHttpInfo($inbox_id, $webhook_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteWebhookAsyncWithHttpInfo
     *
     * Delete and disable a Webhook for an Inbox
     *
     * @param  string $inbox_id (required)
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteWebhookAsyncWithHttpInfo($inbox_id, $webhook_id, string $contentType = self::contentTypes['deleteWebhook'][0])
    {
        $returnType = '';
        $request = $this->deleteWebhookRequest($inbox_id, $webhook_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteWebhook'
     *
     * @param  string $inbox_id (required)
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteWebhookRequest($inbox_id, $webhook_id, string $contentType = self::contentTypes['deleteWebhook'][0])
    {

        // verify the required parameter 'inbox_id' is set
        if ($inbox_id === null || (is_array($inbox_id) && count($inbox_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inbox_id when calling deleteWebhook'
            );
        }

        // verify the required parameter 'webhook_id' is set
        if ($webhook_id === null || (is_array($webhook_id) && count($webhook_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_id when calling deleteWebhook'
            );
        }


        $resourcePath = '/inboxes/{inboxId}/webhooks/{webhookId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($inbox_id !== null) {
            $resourcePath = str_replace(
                '{' . 'inboxId' . '}',
                ObjectSerializer::toPathValue($inbox_id),
                $resourcePath
            );
        }
        // path params
        if ($webhook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhookId' . '}',
                ObjectSerializer::toPathValue($webhook_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteWebhookById
     *
     * Delete a webhook
     *
     * @param  string $webhook_id webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhookById'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteWebhookById($webhook_id, string $contentType = self::contentTypes['deleteWebhookById'][0])
    {
        $this->deleteWebhookByIdWithHttpInfo($webhook_id, $contentType);
    }

    /**
     * Operation deleteWebhookByIdWithHttpInfo
     *
     * Delete a webhook
     *
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhookById'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteWebhookByIdWithHttpInfo($webhook_id, string $contentType = self::contentTypes['deleteWebhookById'][0])
    {
        $request = $this->deleteWebhookByIdRequest($webhook_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteWebhookByIdAsync
     *
     * Delete a webhook
     *
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhookById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteWebhookByIdAsync($webhook_id, string $contentType = self::contentTypes['deleteWebhookById'][0])
    {
        return $this->deleteWebhookByIdAsyncWithHttpInfo($webhook_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteWebhookByIdAsyncWithHttpInfo
     *
     * Delete a webhook
     *
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhookById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteWebhookByIdAsyncWithHttpInfo($webhook_id, string $contentType = self::contentTypes['deleteWebhookById'][0])
    {
        $returnType = '';
        $request = $this->deleteWebhookByIdRequest($webhook_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteWebhookById'
     *
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteWebhookById'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteWebhookByIdRequest($webhook_id, string $contentType = self::contentTypes['deleteWebhookById'][0])
    {

        // verify the required parameter 'webhook_id' is set
        if ($webhook_id === null || (is_array($webhook_id) && count($webhook_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_id when calling deleteWebhookById'
            );
        }


        $resourcePath = '/webhooks/{webhookId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webhook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhookId' . '}',
                ObjectSerializer::toPathValue($webhook_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllAccountWebhooks
     *
     * List account webhooks Paginated
     *
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size for paginated result list. (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'DESC')
     * @param  string $event_type Optional event type (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllAccountWebhooks'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\PageWebhookProjection
     */
    public function getAllAccountWebhooks($page = 0, $size = 20, $sort = 'DESC', $event_type = null, $since = null, $before = null, string $contentType = self::contentTypes['getAllAccountWebhooks'][0])
    {
        list($response) = $this->getAllAccountWebhooksWithHttpInfo($page, $size, $sort, $event_type, $since, $before, $contentType);
        return $response;
    }

    /**
     * Operation getAllAccountWebhooksWithHttpInfo
     *
     * List account webhooks Paginated
     *
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size for paginated result list. (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'DESC')
     * @param  string $event_type Optional event type (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllAccountWebhooks'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\PageWebhookProjection, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllAccountWebhooksWithHttpInfo($page = 0, $size = 20, $sort = 'DESC', $event_type = null, $since = null, $before = null, string $contentType = self::contentTypes['getAllAccountWebhooks'][0])
    {
        $request = $this->getAllAccountWebhooksRequest($page, $size, $sort, $event_type, $since, $before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\PageWebhookProjection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\PageWebhookProjection' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\PageWebhookProjection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\PageWebhookProjection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\PageWebhookProjection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllAccountWebhooksAsync
     *
     * List account webhooks Paginated
     *
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size for paginated result list. (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'DESC')
     * @param  string $event_type Optional event type (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllAccountWebhooks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllAccountWebhooksAsync($page = 0, $size = 20, $sort = 'DESC', $event_type = null, $since = null, $before = null, string $contentType = self::contentTypes['getAllAccountWebhooks'][0])
    {
        return $this->getAllAccountWebhooksAsyncWithHttpInfo($page, $size, $sort, $event_type, $since, $before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllAccountWebhooksAsyncWithHttpInfo
     *
     * List account webhooks Paginated
     *
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size for paginated result list. (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'DESC')
     * @param  string $event_type Optional event type (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllAccountWebhooks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllAccountWebhooksAsyncWithHttpInfo($page = 0, $size = 20, $sort = 'DESC', $event_type = null, $since = null, $before = null, string $contentType = self::contentTypes['getAllAccountWebhooks'][0])
    {
        $returnType = '\MailSlurp\Models\PageWebhookProjection';
        $request = $this->getAllAccountWebhooksRequest($page, $size, $sort, $event_type, $since, $before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllAccountWebhooks'
     *
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size for paginated result list. (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'DESC')
     * @param  string $event_type Optional event type (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllAccountWebhooks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAllAccountWebhooksRequest($page = 0, $size = 20, $sort = 'DESC', $event_type = null, $since = null, $before = null, string $contentType = self::contentTypes['getAllAccountWebhooks'][0])
    {

        if ($page !== null && $page > 9223372036854775807) {
            throw new \InvalidArgumentException('invalid value for "$page" when calling WebhookControllerApi.getAllAccountWebhooks, must be smaller than or equal to 9223372036854775807.');
        }
        if ($page !== null && $page < 0) {
            throw new \InvalidArgumentException('invalid value for "$page" when calling WebhookControllerApi.getAllAccountWebhooks, must be bigger than or equal to 0.');
        }
        
        if ($size !== null && $size > 100) {
            throw new \InvalidArgumentException('invalid value for "$size" when calling WebhookControllerApi.getAllAccountWebhooks, must be smaller than or equal to 100.');
        }
        if ($size !== null && $size < 1) {
            throw new \InvalidArgumentException('invalid value for "$size" when calling WebhookControllerApi.getAllAccountWebhooks, must be bigger than or equal to 1.');
        }
        





        $resourcePath = '/webhooks/account/paginated';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size,
            'size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $event_type,
            'eventType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $since,
            'since', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $before,
            'before', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllWebhookResults
     *
     * Get results for all webhooks
     *
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size in list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  string $search_filter Optional search filter (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  bool $unseen_only Filter for unseen exceptions only (optional)
     * @param  string $result_type Filter by result type (optional)
     * @param  string $event_name Filter by event name (optional)
     * @param  int $min_status_code Minimum response status (optional)
     * @param  int $max_status_code Maximum response status (optional)
     * @param  string $inbox_id Inbox ID (optional)
     * @param  string $sms_id Sms ID (optional)
     * @param  string $attachment_id Attachment ID (optional)
     * @param  string $email_id Email ID (optional)
     * @param  string $phone_id Phone ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllWebhookResults'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\PageWebhookResult
     */
    public function getAllWebhookResults($page = 0, $size = 20, $sort = 'ASC', $search_filter = null, $since = null, $before = null, $unseen_only = null, $result_type = null, $event_name = null, $min_status_code = null, $max_status_code = null, $inbox_id = null, $sms_id = null, $attachment_id = null, $email_id = null, $phone_id = null, string $contentType = self::contentTypes['getAllWebhookResults'][0])
    {
        list($response) = $this->getAllWebhookResultsWithHttpInfo($page, $size, $sort, $search_filter, $since, $before, $unseen_only, $result_type, $event_name, $min_status_code, $max_status_code, $inbox_id, $sms_id, $attachment_id, $email_id, $phone_id, $contentType);
        return $response;
    }

    /**
     * Operation getAllWebhookResultsWithHttpInfo
     *
     * Get results for all webhooks
     *
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size in list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  string $search_filter Optional search filter (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  bool $unseen_only Filter for unseen exceptions only (optional)
     * @param  string $result_type Filter by result type (optional)
     * @param  string $event_name Filter by event name (optional)
     * @param  int $min_status_code Minimum response status (optional)
     * @param  int $max_status_code Maximum response status (optional)
     * @param  string $inbox_id Inbox ID (optional)
     * @param  string $sms_id Sms ID (optional)
     * @param  string $attachment_id Attachment ID (optional)
     * @param  string $email_id Email ID (optional)
     * @param  string $phone_id Phone ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllWebhookResults'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\PageWebhookResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllWebhookResultsWithHttpInfo($page = 0, $size = 20, $sort = 'ASC', $search_filter = null, $since = null, $before = null, $unseen_only = null, $result_type = null, $event_name = null, $min_status_code = null, $max_status_code = null, $inbox_id = null, $sms_id = null, $attachment_id = null, $email_id = null, $phone_id = null, string $contentType = self::contentTypes['getAllWebhookResults'][0])
    {
        $request = $this->getAllWebhookResultsRequest($page, $size, $sort, $search_filter, $since, $before, $unseen_only, $result_type, $event_name, $min_status_code, $max_status_code, $inbox_id, $sms_id, $attachment_id, $email_id, $phone_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\PageWebhookResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\PageWebhookResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\PageWebhookResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\PageWebhookResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\PageWebhookResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllWebhookResultsAsync
     *
     * Get results for all webhooks
     *
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size in list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  string $search_filter Optional search filter (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  bool $unseen_only Filter for unseen exceptions only (optional)
     * @param  string $result_type Filter by result type (optional)
     * @param  string $event_name Filter by event name (optional)
     * @param  int $min_status_code Minimum response status (optional)
     * @param  int $max_status_code Maximum response status (optional)
     * @param  string $inbox_id Inbox ID (optional)
     * @param  string $sms_id Sms ID (optional)
     * @param  string $attachment_id Attachment ID (optional)
     * @param  string $email_id Email ID (optional)
     * @param  string $phone_id Phone ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllWebhookResults'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllWebhookResultsAsync($page = 0, $size = 20, $sort = 'ASC', $search_filter = null, $since = null, $before = null, $unseen_only = null, $result_type = null, $event_name = null, $min_status_code = null, $max_status_code = null, $inbox_id = null, $sms_id = null, $attachment_id = null, $email_id = null, $phone_id = null, string $contentType = self::contentTypes['getAllWebhookResults'][0])
    {
        return $this->getAllWebhookResultsAsyncWithHttpInfo($page, $size, $sort, $search_filter, $since, $before, $unseen_only, $result_type, $event_name, $min_status_code, $max_status_code, $inbox_id, $sms_id, $attachment_id, $email_id, $phone_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllWebhookResultsAsyncWithHttpInfo
     *
     * Get results for all webhooks
     *
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size in list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  string $search_filter Optional search filter (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  bool $unseen_only Filter for unseen exceptions only (optional)
     * @param  string $result_type Filter by result type (optional)
     * @param  string $event_name Filter by event name (optional)
     * @param  int $min_status_code Minimum response status (optional)
     * @param  int $max_status_code Maximum response status (optional)
     * @param  string $inbox_id Inbox ID (optional)
     * @param  string $sms_id Sms ID (optional)
     * @param  string $attachment_id Attachment ID (optional)
     * @param  string $email_id Email ID (optional)
     * @param  string $phone_id Phone ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllWebhookResults'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllWebhookResultsAsyncWithHttpInfo($page = 0, $size = 20, $sort = 'ASC', $search_filter = null, $since = null, $before = null, $unseen_only = null, $result_type = null, $event_name = null, $min_status_code = null, $max_status_code = null, $inbox_id = null, $sms_id = null, $attachment_id = null, $email_id = null, $phone_id = null, string $contentType = self::contentTypes['getAllWebhookResults'][0])
    {
        $returnType = '\MailSlurp\Models\PageWebhookResult';
        $request = $this->getAllWebhookResultsRequest($page, $size, $sort, $search_filter, $since, $before, $unseen_only, $result_type, $event_name, $min_status_code, $max_status_code, $inbox_id, $sms_id, $attachment_id, $email_id, $phone_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllWebhookResults'
     *
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size in list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  string $search_filter Optional search filter (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  bool $unseen_only Filter for unseen exceptions only (optional)
     * @param  string $result_type Filter by result type (optional)
     * @param  string $event_name Filter by event name (optional)
     * @param  int $min_status_code Minimum response status (optional)
     * @param  int $max_status_code Maximum response status (optional)
     * @param  string $inbox_id Inbox ID (optional)
     * @param  string $sms_id Sms ID (optional)
     * @param  string $attachment_id Attachment ID (optional)
     * @param  string $email_id Email ID (optional)
     * @param  string $phone_id Phone ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllWebhookResults'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAllWebhookResultsRequest($page = 0, $size = 20, $sort = 'ASC', $search_filter = null, $since = null, $before = null, $unseen_only = null, $result_type = null, $event_name = null, $min_status_code = null, $max_status_code = null, $inbox_id = null, $sms_id = null, $attachment_id = null, $email_id = null, $phone_id = null, string $contentType = self::contentTypes['getAllWebhookResults'][0])
    {


















        $resourcePath = '/webhooks/results';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size,
            'size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_filter,
            'searchFilter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $since,
            'since', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $before,
            'before', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unseen_only,
            'unseenOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $result_type,
            'resultType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $event_name,
            'eventName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_status_code,
            'minStatusCode', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_status_code,
            'maxStatusCode', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $inbox_id,
            'inboxId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sms_id,
            'smsId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $attachment_id,
            'attachmentId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email_id,
            'emailId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $phone_id,
            'phoneId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllWebhooks
     *
     * List Webhooks Paginated
     *
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size for paginated result list. (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'DESC')
     * @param  string $search_filter Optional search filter (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  string $inbox_id Filter by inboxId (optional)
     * @param  string $phone_id Filter by phoneId (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllWebhooks'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\PageWebhookProjection
     */
    public function getAllWebhooks($page = 0, $size = 20, $sort = 'DESC', $search_filter = null, $since = null, $inbox_id = null, $phone_id = null, $before = null, string $contentType = self::contentTypes['getAllWebhooks'][0])
    {
        list($response) = $this->getAllWebhooksWithHttpInfo($page, $size, $sort, $search_filter, $since, $inbox_id, $phone_id, $before, $contentType);
        return $response;
    }

    /**
     * Operation getAllWebhooksWithHttpInfo
     *
     * List Webhooks Paginated
     *
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size for paginated result list. (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'DESC')
     * @param  string $search_filter Optional search filter (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  string $inbox_id Filter by inboxId (optional)
     * @param  string $phone_id Filter by phoneId (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllWebhooks'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\PageWebhookProjection, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllWebhooksWithHttpInfo($page = 0, $size = 20, $sort = 'DESC', $search_filter = null, $since = null, $inbox_id = null, $phone_id = null, $before = null, string $contentType = self::contentTypes['getAllWebhooks'][0])
    {
        $request = $this->getAllWebhooksRequest($page, $size, $sort, $search_filter, $since, $inbox_id, $phone_id, $before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\PageWebhookProjection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\PageWebhookProjection' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\PageWebhookProjection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\PageWebhookProjection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\PageWebhookProjection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllWebhooksAsync
     *
     * List Webhooks Paginated
     *
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size for paginated result list. (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'DESC')
     * @param  string $search_filter Optional search filter (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  string $inbox_id Filter by inboxId (optional)
     * @param  string $phone_id Filter by phoneId (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllWebhooks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllWebhooksAsync($page = 0, $size = 20, $sort = 'DESC', $search_filter = null, $since = null, $inbox_id = null, $phone_id = null, $before = null, string $contentType = self::contentTypes['getAllWebhooks'][0])
    {
        return $this->getAllWebhooksAsyncWithHttpInfo($page, $size, $sort, $search_filter, $since, $inbox_id, $phone_id, $before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllWebhooksAsyncWithHttpInfo
     *
     * List Webhooks Paginated
     *
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size for paginated result list. (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'DESC')
     * @param  string $search_filter Optional search filter (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  string $inbox_id Filter by inboxId (optional)
     * @param  string $phone_id Filter by phoneId (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllWebhooks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllWebhooksAsyncWithHttpInfo($page = 0, $size = 20, $sort = 'DESC', $search_filter = null, $since = null, $inbox_id = null, $phone_id = null, $before = null, string $contentType = self::contentTypes['getAllWebhooks'][0])
    {
        $returnType = '\MailSlurp\Models\PageWebhookProjection';
        $request = $this->getAllWebhooksRequest($page, $size, $sort, $search_filter, $since, $inbox_id, $phone_id, $before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllWebhooks'
     *
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size for paginated result list. (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'DESC')
     * @param  string $search_filter Optional search filter (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  string $inbox_id Filter by inboxId (optional)
     * @param  string $phone_id Filter by phoneId (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAllWebhooks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAllWebhooksRequest($page = 0, $size = 20, $sort = 'DESC', $search_filter = null, $since = null, $inbox_id = null, $phone_id = null, $before = null, string $contentType = self::contentTypes['getAllWebhooks'][0])
    {

        if ($page !== null && $page > 9223372036854775807) {
            throw new \InvalidArgumentException('invalid value for "$page" when calling WebhookControllerApi.getAllWebhooks, must be smaller than or equal to 9223372036854775807.');
        }
        if ($page !== null && $page < 0) {
            throw new \InvalidArgumentException('invalid value for "$page" when calling WebhookControllerApi.getAllWebhooks, must be bigger than or equal to 0.');
        }
        
        if ($size !== null && $size > 100) {
            throw new \InvalidArgumentException('invalid value for "$size" when calling WebhookControllerApi.getAllWebhooks, must be smaller than or equal to 100.');
        }
        if ($size !== null && $size < 1) {
            throw new \InvalidArgumentException('invalid value for "$size" when calling WebhookControllerApi.getAllWebhooks, must be bigger than or equal to 1.');
        }
        







        $resourcePath = '/webhooks/paginated';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size,
            'size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_filter,
            'searchFilter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $since,
            'since', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $inbox_id,
            'inboxId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $phone_id,
            'phoneId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $before,
            'before', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInboxWebhooksPaginated
     *
     * Get paginated webhooks for an Inbox
     *
     * @param  string $inbox_id inbox_id (required)
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size in list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  string $search_filter Optional search filter (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInboxWebhooksPaginated'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\PageWebhookProjection
     */
    public function getInboxWebhooksPaginated($inbox_id, $page = 0, $size = 20, $sort = 'ASC', $search_filter = null, $since = null, $before = null, string $contentType = self::contentTypes['getInboxWebhooksPaginated'][0])
    {
        list($response) = $this->getInboxWebhooksPaginatedWithHttpInfo($inbox_id, $page, $size, $sort, $search_filter, $since, $before, $contentType);
        return $response;
    }

    /**
     * Operation getInboxWebhooksPaginatedWithHttpInfo
     *
     * Get paginated webhooks for an Inbox
     *
     * @param  string $inbox_id (required)
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size in list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  string $search_filter Optional search filter (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInboxWebhooksPaginated'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\PageWebhookProjection, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInboxWebhooksPaginatedWithHttpInfo($inbox_id, $page = 0, $size = 20, $sort = 'ASC', $search_filter = null, $since = null, $before = null, string $contentType = self::contentTypes['getInboxWebhooksPaginated'][0])
    {
        $request = $this->getInboxWebhooksPaginatedRequest($inbox_id, $page, $size, $sort, $search_filter, $since, $before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\PageWebhookProjection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\PageWebhookProjection' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\PageWebhookProjection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\PageWebhookProjection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\PageWebhookProjection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInboxWebhooksPaginatedAsync
     *
     * Get paginated webhooks for an Inbox
     *
     * @param  string $inbox_id (required)
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size in list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  string $search_filter Optional search filter (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInboxWebhooksPaginated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInboxWebhooksPaginatedAsync($inbox_id, $page = 0, $size = 20, $sort = 'ASC', $search_filter = null, $since = null, $before = null, string $contentType = self::contentTypes['getInboxWebhooksPaginated'][0])
    {
        return $this->getInboxWebhooksPaginatedAsyncWithHttpInfo($inbox_id, $page, $size, $sort, $search_filter, $since, $before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInboxWebhooksPaginatedAsyncWithHttpInfo
     *
     * Get paginated webhooks for an Inbox
     *
     * @param  string $inbox_id (required)
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size in list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  string $search_filter Optional search filter (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInboxWebhooksPaginated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInboxWebhooksPaginatedAsyncWithHttpInfo($inbox_id, $page = 0, $size = 20, $sort = 'ASC', $search_filter = null, $since = null, $before = null, string $contentType = self::contentTypes['getInboxWebhooksPaginated'][0])
    {
        $returnType = '\MailSlurp\Models\PageWebhookProjection';
        $request = $this->getInboxWebhooksPaginatedRequest($inbox_id, $page, $size, $sort, $search_filter, $since, $before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInboxWebhooksPaginated'
     *
     * @param  string $inbox_id (required)
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size in list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  string $search_filter Optional search filter (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInboxWebhooksPaginated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getInboxWebhooksPaginatedRequest($inbox_id, $page = 0, $size = 20, $sort = 'ASC', $search_filter = null, $since = null, $before = null, string $contentType = self::contentTypes['getInboxWebhooksPaginated'][0])
    {

        // verify the required parameter 'inbox_id' is set
        if ($inbox_id === null || (is_array($inbox_id) && count($inbox_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inbox_id when calling getInboxWebhooksPaginated'
            );
        }








        $resourcePath = '/inboxes/{inboxId}/webhooks/paginated';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size,
            'size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_filter,
            'searchFilter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $since,
            'since', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $before,
            'before', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($inbox_id !== null) {
            $resourcePath = str_replace(
                '{' . 'inboxId' . '}',
                ObjectSerializer::toPathValue($inbox_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getJsonSchemaForWebhookEvent
     *
     * @param  string $event event (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getJsonSchemaForWebhookEvent'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\JSONSchemaDto
     */
    public function getJsonSchemaForWebhookEvent($event, string $contentType = self::contentTypes['getJsonSchemaForWebhookEvent'][0])
    {
        list($response) = $this->getJsonSchemaForWebhookEventWithHttpInfo($event, $contentType);
        return $response;
    }

    /**
     * Operation getJsonSchemaForWebhookEventWithHttpInfo
     *
     * @param  string $event (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getJsonSchemaForWebhookEvent'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\JSONSchemaDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getJsonSchemaForWebhookEventWithHttpInfo($event, string $contentType = self::contentTypes['getJsonSchemaForWebhookEvent'][0])
    {
        $request = $this->getJsonSchemaForWebhookEventRequest($event, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\JSONSchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\JSONSchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\JSONSchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\JSONSchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\JSONSchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getJsonSchemaForWebhookEventAsync
     *
     * @param  string $event (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getJsonSchemaForWebhookEvent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getJsonSchemaForWebhookEventAsync($event, string $contentType = self::contentTypes['getJsonSchemaForWebhookEvent'][0])
    {
        return $this->getJsonSchemaForWebhookEventAsyncWithHttpInfo($event, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getJsonSchemaForWebhookEventAsyncWithHttpInfo
     *
     * @param  string $event (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getJsonSchemaForWebhookEvent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getJsonSchemaForWebhookEventAsyncWithHttpInfo($event, string $contentType = self::contentTypes['getJsonSchemaForWebhookEvent'][0])
    {
        $returnType = '\MailSlurp\Models\JSONSchemaDto';
        $request = $this->getJsonSchemaForWebhookEventRequest($event, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getJsonSchemaForWebhookEvent'
     *
     * @param  string $event (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getJsonSchemaForWebhookEvent'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getJsonSchemaForWebhookEventRequest($event, string $contentType = self::contentTypes['getJsonSchemaForWebhookEvent'][0])
    {

        // verify the required parameter 'event' is set
        if ($event === null || (is_array($event) && count($event) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $event when calling getJsonSchemaForWebhookEvent'
            );
        }


        $resourcePath = '/webhooks/schema';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $event,
            'event', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getJsonSchemaForWebhookPayload
     *
     * @param  string $webhook_id webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getJsonSchemaForWebhookPayload'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\JSONSchemaDto
     */
    public function getJsonSchemaForWebhookPayload($webhook_id, string $contentType = self::contentTypes['getJsonSchemaForWebhookPayload'][0])
    {
        list($response) = $this->getJsonSchemaForWebhookPayloadWithHttpInfo($webhook_id, $contentType);
        return $response;
    }

    /**
     * Operation getJsonSchemaForWebhookPayloadWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getJsonSchemaForWebhookPayload'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\JSONSchemaDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getJsonSchemaForWebhookPayloadWithHttpInfo($webhook_id, string $contentType = self::contentTypes['getJsonSchemaForWebhookPayload'][0])
    {
        $request = $this->getJsonSchemaForWebhookPayloadRequest($webhook_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\JSONSchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\JSONSchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\JSONSchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\JSONSchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\JSONSchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getJsonSchemaForWebhookPayloadAsync
     *
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getJsonSchemaForWebhookPayload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getJsonSchemaForWebhookPayloadAsync($webhook_id, string $contentType = self::contentTypes['getJsonSchemaForWebhookPayload'][0])
    {
        return $this->getJsonSchemaForWebhookPayloadAsyncWithHttpInfo($webhook_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getJsonSchemaForWebhookPayloadAsyncWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getJsonSchemaForWebhookPayload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getJsonSchemaForWebhookPayloadAsyncWithHttpInfo($webhook_id, string $contentType = self::contentTypes['getJsonSchemaForWebhookPayload'][0])
    {
        $returnType = '\MailSlurp\Models\JSONSchemaDto';
        $request = $this->getJsonSchemaForWebhookPayloadRequest($webhook_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getJsonSchemaForWebhookPayload'
     *
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getJsonSchemaForWebhookPayload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getJsonSchemaForWebhookPayloadRequest($webhook_id, string $contentType = self::contentTypes['getJsonSchemaForWebhookPayload'][0])
    {

        // verify the required parameter 'webhook_id' is set
        if ($webhook_id === null || (is_array($webhook_id) && count($webhook_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_id when calling getJsonSchemaForWebhookPayload'
            );
        }


        $resourcePath = '/webhooks/{webhookId}/schema';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webhook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhookId' . '}',
                ObjectSerializer::toPathValue($webhook_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPhoneNumberWebhooksPaginated
     *
     * Get paginated webhooks for a phone number
     *
     * @param  string $phone_id phone_id (required)
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size in list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPhoneNumberWebhooksPaginated'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\PageWebhookProjection
     */
    public function getPhoneNumberWebhooksPaginated($phone_id, $page = 0, $size = 20, $sort = 'ASC', $since = null, $before = null, string $contentType = self::contentTypes['getPhoneNumberWebhooksPaginated'][0])
    {
        list($response) = $this->getPhoneNumberWebhooksPaginatedWithHttpInfo($phone_id, $page, $size, $sort, $since, $before, $contentType);
        return $response;
    }

    /**
     * Operation getPhoneNumberWebhooksPaginatedWithHttpInfo
     *
     * Get paginated webhooks for a phone number
     *
     * @param  string $phone_id (required)
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size in list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPhoneNumberWebhooksPaginated'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\PageWebhookProjection, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPhoneNumberWebhooksPaginatedWithHttpInfo($phone_id, $page = 0, $size = 20, $sort = 'ASC', $since = null, $before = null, string $contentType = self::contentTypes['getPhoneNumberWebhooksPaginated'][0])
    {
        $request = $this->getPhoneNumberWebhooksPaginatedRequest($phone_id, $page, $size, $sort, $since, $before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\PageWebhookProjection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\PageWebhookProjection' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\PageWebhookProjection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\PageWebhookProjection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\PageWebhookProjection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPhoneNumberWebhooksPaginatedAsync
     *
     * Get paginated webhooks for a phone number
     *
     * @param  string $phone_id (required)
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size in list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPhoneNumberWebhooksPaginated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPhoneNumberWebhooksPaginatedAsync($phone_id, $page = 0, $size = 20, $sort = 'ASC', $since = null, $before = null, string $contentType = self::contentTypes['getPhoneNumberWebhooksPaginated'][0])
    {
        return $this->getPhoneNumberWebhooksPaginatedAsyncWithHttpInfo($phone_id, $page, $size, $sort, $since, $before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPhoneNumberWebhooksPaginatedAsyncWithHttpInfo
     *
     * Get paginated webhooks for a phone number
     *
     * @param  string $phone_id (required)
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size in list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPhoneNumberWebhooksPaginated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPhoneNumberWebhooksPaginatedAsyncWithHttpInfo($phone_id, $page = 0, $size = 20, $sort = 'ASC', $since = null, $before = null, string $contentType = self::contentTypes['getPhoneNumberWebhooksPaginated'][0])
    {
        $returnType = '\MailSlurp\Models\PageWebhookProjection';
        $request = $this->getPhoneNumberWebhooksPaginatedRequest($phone_id, $page, $size, $sort, $since, $before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPhoneNumberWebhooksPaginated'
     *
     * @param  string $phone_id (required)
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size in list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getPhoneNumberWebhooksPaginated'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getPhoneNumberWebhooksPaginatedRequest($phone_id, $page = 0, $size = 20, $sort = 'ASC', $since = null, $before = null, string $contentType = self::contentTypes['getPhoneNumberWebhooksPaginated'][0])
    {

        // verify the required parameter 'phone_id' is set
        if ($phone_id === null || (is_array($phone_id) && count($phone_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $phone_id when calling getPhoneNumberWebhooksPaginated'
            );
        }







        $resourcePath = '/phone/numbers/{phoneId}/webhooks/paginated';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size,
            'size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $since,
            'since', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $before,
            'before', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($phone_id !== null) {
            $resourcePath = str_replace(
                '{' . 'phoneId' . '}',
                ObjectSerializer::toPathValue($phone_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTestWebhookPayload
     *
     * @param  string $event_name event_name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayload'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\AbstractWebhookPayload
     */
    public function getTestWebhookPayload($event_name = null, string $contentType = self::contentTypes['getTestWebhookPayload'][0])
    {
        list($response) = $this->getTestWebhookPayloadWithHttpInfo($event_name, $contentType);
        return $response;
    }

    /**
     * Operation getTestWebhookPayloadWithHttpInfo
     *
     * @param  string $event_name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayload'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\AbstractWebhookPayload, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTestWebhookPayloadWithHttpInfo($event_name = null, string $contentType = self::contentTypes['getTestWebhookPayload'][0])
    {
        $request = $this->getTestWebhookPayloadRequest($event_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\AbstractWebhookPayload' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\AbstractWebhookPayload' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\AbstractWebhookPayload', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\AbstractWebhookPayload';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\AbstractWebhookPayload',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTestWebhookPayloadAsync
     *
     * @param  string $event_name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTestWebhookPayloadAsync($event_name = null, string $contentType = self::contentTypes['getTestWebhookPayload'][0])
    {
        return $this->getTestWebhookPayloadAsyncWithHttpInfo($event_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTestWebhookPayloadAsyncWithHttpInfo
     *
     * @param  string $event_name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTestWebhookPayloadAsyncWithHttpInfo($event_name = null, string $contentType = self::contentTypes['getTestWebhookPayload'][0])
    {
        $returnType = '\MailSlurp\Models\AbstractWebhookPayload';
        $request = $this->getTestWebhookPayloadRequest($event_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTestWebhookPayload'
     *
     * @param  string $event_name (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayload'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTestWebhookPayloadRequest($event_name = null, string $contentType = self::contentTypes['getTestWebhookPayload'][0])
    {



        $resourcePath = '/webhooks/test';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $event_name,
            'eventName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTestWebhookPayloadBounce
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadBounce'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\WebhookBouncePayload
     */
    public function getTestWebhookPayloadBounce(string $contentType = self::contentTypes['getTestWebhookPayloadBounce'][0])
    {
        list($response) = $this->getTestWebhookPayloadBounceWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getTestWebhookPayloadBounceWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadBounce'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\WebhookBouncePayload, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTestWebhookPayloadBounceWithHttpInfo(string $contentType = self::contentTypes['getTestWebhookPayloadBounce'][0])
    {
        $request = $this->getTestWebhookPayloadBounceRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\WebhookBouncePayload' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\WebhookBouncePayload' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\WebhookBouncePayload', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\WebhookBouncePayload';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\WebhookBouncePayload',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTestWebhookPayloadBounceAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadBounce'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTestWebhookPayloadBounceAsync(string $contentType = self::contentTypes['getTestWebhookPayloadBounce'][0])
    {
        return $this->getTestWebhookPayloadBounceAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTestWebhookPayloadBounceAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadBounce'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTestWebhookPayloadBounceAsyncWithHttpInfo(string $contentType = self::contentTypes['getTestWebhookPayloadBounce'][0])
    {
        $returnType = '\MailSlurp\Models\WebhookBouncePayload';
        $request = $this->getTestWebhookPayloadBounceRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTestWebhookPayloadBounce'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadBounce'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTestWebhookPayloadBounceRequest(string $contentType = self::contentTypes['getTestWebhookPayloadBounce'][0])
    {


        $resourcePath = '/webhooks/test/email-bounce-payload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTestWebhookPayloadBounceRecipient
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadBounceRecipient'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\WebhookBounceRecipientPayload
     */
    public function getTestWebhookPayloadBounceRecipient(string $contentType = self::contentTypes['getTestWebhookPayloadBounceRecipient'][0])
    {
        list($response) = $this->getTestWebhookPayloadBounceRecipientWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getTestWebhookPayloadBounceRecipientWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadBounceRecipient'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\WebhookBounceRecipientPayload, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTestWebhookPayloadBounceRecipientWithHttpInfo(string $contentType = self::contentTypes['getTestWebhookPayloadBounceRecipient'][0])
    {
        $request = $this->getTestWebhookPayloadBounceRecipientRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\WebhookBounceRecipientPayload' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\WebhookBounceRecipientPayload' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\WebhookBounceRecipientPayload', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\WebhookBounceRecipientPayload';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\WebhookBounceRecipientPayload',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTestWebhookPayloadBounceRecipientAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadBounceRecipient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTestWebhookPayloadBounceRecipientAsync(string $contentType = self::contentTypes['getTestWebhookPayloadBounceRecipient'][0])
    {
        return $this->getTestWebhookPayloadBounceRecipientAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTestWebhookPayloadBounceRecipientAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadBounceRecipient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTestWebhookPayloadBounceRecipientAsyncWithHttpInfo(string $contentType = self::contentTypes['getTestWebhookPayloadBounceRecipient'][0])
    {
        $returnType = '\MailSlurp\Models\WebhookBounceRecipientPayload';
        $request = $this->getTestWebhookPayloadBounceRecipientRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTestWebhookPayloadBounceRecipient'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadBounceRecipient'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTestWebhookPayloadBounceRecipientRequest(string $contentType = self::contentTypes['getTestWebhookPayloadBounceRecipient'][0])
    {


        $resourcePath = '/webhooks/test/email-bounce-recipient-payload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTestWebhookPayloadDeliveryStatus
     *
     * Get webhook test payload for delivery status event
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadDeliveryStatus'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\WebhookDeliveryStatusPayload
     */
    public function getTestWebhookPayloadDeliveryStatus(string $contentType = self::contentTypes['getTestWebhookPayloadDeliveryStatus'][0])
    {
        list($response) = $this->getTestWebhookPayloadDeliveryStatusWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getTestWebhookPayloadDeliveryStatusWithHttpInfo
     *
     * Get webhook test payload for delivery status event
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadDeliveryStatus'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\WebhookDeliveryStatusPayload, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTestWebhookPayloadDeliveryStatusWithHttpInfo(string $contentType = self::contentTypes['getTestWebhookPayloadDeliveryStatus'][0])
    {
        $request = $this->getTestWebhookPayloadDeliveryStatusRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\WebhookDeliveryStatusPayload' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\WebhookDeliveryStatusPayload' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\WebhookDeliveryStatusPayload', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\WebhookDeliveryStatusPayload';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\WebhookDeliveryStatusPayload',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTestWebhookPayloadDeliveryStatusAsync
     *
     * Get webhook test payload for delivery status event
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadDeliveryStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTestWebhookPayloadDeliveryStatusAsync(string $contentType = self::contentTypes['getTestWebhookPayloadDeliveryStatus'][0])
    {
        return $this->getTestWebhookPayloadDeliveryStatusAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTestWebhookPayloadDeliveryStatusAsyncWithHttpInfo
     *
     * Get webhook test payload for delivery status event
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadDeliveryStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTestWebhookPayloadDeliveryStatusAsyncWithHttpInfo(string $contentType = self::contentTypes['getTestWebhookPayloadDeliveryStatus'][0])
    {
        $returnType = '\MailSlurp\Models\WebhookDeliveryStatusPayload';
        $request = $this->getTestWebhookPayloadDeliveryStatusRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTestWebhookPayloadDeliveryStatus'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadDeliveryStatus'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTestWebhookPayloadDeliveryStatusRequest(string $contentType = self::contentTypes['getTestWebhookPayloadDeliveryStatus'][0])
    {


        $resourcePath = '/webhooks/test/delivery-status-payload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTestWebhookPayloadEmailOpened
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadEmailOpened'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\WebhookEmailOpenedPayload
     */
    public function getTestWebhookPayloadEmailOpened(string $contentType = self::contentTypes['getTestWebhookPayloadEmailOpened'][0])
    {
        list($response) = $this->getTestWebhookPayloadEmailOpenedWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getTestWebhookPayloadEmailOpenedWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadEmailOpened'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\WebhookEmailOpenedPayload, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTestWebhookPayloadEmailOpenedWithHttpInfo(string $contentType = self::contentTypes['getTestWebhookPayloadEmailOpened'][0])
    {
        $request = $this->getTestWebhookPayloadEmailOpenedRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\WebhookEmailOpenedPayload' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\WebhookEmailOpenedPayload' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\WebhookEmailOpenedPayload', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\WebhookEmailOpenedPayload';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\WebhookEmailOpenedPayload',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTestWebhookPayloadEmailOpenedAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadEmailOpened'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTestWebhookPayloadEmailOpenedAsync(string $contentType = self::contentTypes['getTestWebhookPayloadEmailOpened'][0])
    {
        return $this->getTestWebhookPayloadEmailOpenedAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTestWebhookPayloadEmailOpenedAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadEmailOpened'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTestWebhookPayloadEmailOpenedAsyncWithHttpInfo(string $contentType = self::contentTypes['getTestWebhookPayloadEmailOpened'][0])
    {
        $returnType = '\MailSlurp\Models\WebhookEmailOpenedPayload';
        $request = $this->getTestWebhookPayloadEmailOpenedRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTestWebhookPayloadEmailOpened'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadEmailOpened'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTestWebhookPayloadEmailOpenedRequest(string $contentType = self::contentTypes['getTestWebhookPayloadEmailOpened'][0])
    {


        $resourcePath = '/webhooks/test/email-opened-payload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTestWebhookPayloadEmailRead
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadEmailRead'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\WebhookEmailReadPayload
     */
    public function getTestWebhookPayloadEmailRead(string $contentType = self::contentTypes['getTestWebhookPayloadEmailRead'][0])
    {
        list($response) = $this->getTestWebhookPayloadEmailReadWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getTestWebhookPayloadEmailReadWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadEmailRead'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\WebhookEmailReadPayload, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTestWebhookPayloadEmailReadWithHttpInfo(string $contentType = self::contentTypes['getTestWebhookPayloadEmailRead'][0])
    {
        $request = $this->getTestWebhookPayloadEmailReadRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\WebhookEmailReadPayload' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\WebhookEmailReadPayload' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\WebhookEmailReadPayload', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\WebhookEmailReadPayload';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\WebhookEmailReadPayload',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTestWebhookPayloadEmailReadAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadEmailRead'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTestWebhookPayloadEmailReadAsync(string $contentType = self::contentTypes['getTestWebhookPayloadEmailRead'][0])
    {
        return $this->getTestWebhookPayloadEmailReadAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTestWebhookPayloadEmailReadAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadEmailRead'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTestWebhookPayloadEmailReadAsyncWithHttpInfo(string $contentType = self::contentTypes['getTestWebhookPayloadEmailRead'][0])
    {
        $returnType = '\MailSlurp\Models\WebhookEmailReadPayload';
        $request = $this->getTestWebhookPayloadEmailReadRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTestWebhookPayloadEmailRead'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadEmailRead'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTestWebhookPayloadEmailReadRequest(string $contentType = self::contentTypes['getTestWebhookPayloadEmailRead'][0])
    {


        $resourcePath = '/webhooks/test/email-read-payload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTestWebhookPayloadForWebhook
     *
     * @param  string $webhook_id webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadForWebhook'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\AbstractWebhookPayload
     */
    public function getTestWebhookPayloadForWebhook($webhook_id, string $contentType = self::contentTypes['getTestWebhookPayloadForWebhook'][0])
    {
        list($response) = $this->getTestWebhookPayloadForWebhookWithHttpInfo($webhook_id, $contentType);
        return $response;
    }

    /**
     * Operation getTestWebhookPayloadForWebhookWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadForWebhook'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\AbstractWebhookPayload, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTestWebhookPayloadForWebhookWithHttpInfo($webhook_id, string $contentType = self::contentTypes['getTestWebhookPayloadForWebhook'][0])
    {
        $request = $this->getTestWebhookPayloadForWebhookRequest($webhook_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\MailSlurp\Models\AbstractWebhookPayload' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\AbstractWebhookPayload' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\AbstractWebhookPayload', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\AbstractWebhookPayload';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\AbstractWebhookPayload',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTestWebhookPayloadForWebhookAsync
     *
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadForWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTestWebhookPayloadForWebhookAsync($webhook_id, string $contentType = self::contentTypes['getTestWebhookPayloadForWebhook'][0])
    {
        return $this->getTestWebhookPayloadForWebhookAsyncWithHttpInfo($webhook_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTestWebhookPayloadForWebhookAsyncWithHttpInfo
     *
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadForWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTestWebhookPayloadForWebhookAsyncWithHttpInfo($webhook_id, string $contentType = self::contentTypes['getTestWebhookPayloadForWebhook'][0])
    {
        $returnType = '\MailSlurp\Models\AbstractWebhookPayload';
        $request = $this->getTestWebhookPayloadForWebhookRequest($webhook_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTestWebhookPayloadForWebhook'
     *
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadForWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTestWebhookPayloadForWebhookRequest($webhook_id, string $contentType = self::contentTypes['getTestWebhookPayloadForWebhook'][0])
    {

        // verify the required parameter 'webhook_id' is set
        if ($webhook_id === null || (is_array($webhook_id) && count($webhook_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_id when calling getTestWebhookPayloadForWebhook'
            );
        }


        $resourcePath = '/webhooks/{webhookId}/example';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webhook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhookId' . '}',
                ObjectSerializer::toPathValue($webhook_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTestWebhookPayloadNewAttachment
     *
     * Get webhook test payload for new attachment event
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadNewAttachment'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\WebhookNewAttachmentPayload
     */
    public function getTestWebhookPayloadNewAttachment(string $contentType = self::contentTypes['getTestWebhookPayloadNewAttachment'][0])
    {
        list($response) = $this->getTestWebhookPayloadNewAttachmentWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getTestWebhookPayloadNewAttachmentWithHttpInfo
     *
     * Get webhook test payload for new attachment event
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadNewAttachment'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\WebhookNewAttachmentPayload, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTestWebhookPayloadNewAttachmentWithHttpInfo(string $contentType = self::contentTypes['getTestWebhookPayloadNewAttachment'][0])
    {
        $request = $this->getTestWebhookPayloadNewAttachmentRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\WebhookNewAttachmentPayload' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\WebhookNewAttachmentPayload' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\WebhookNewAttachmentPayload', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\WebhookNewAttachmentPayload';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\WebhookNewAttachmentPayload',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTestWebhookPayloadNewAttachmentAsync
     *
     * Get webhook test payload for new attachment event
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadNewAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTestWebhookPayloadNewAttachmentAsync(string $contentType = self::contentTypes['getTestWebhookPayloadNewAttachment'][0])
    {
        return $this->getTestWebhookPayloadNewAttachmentAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTestWebhookPayloadNewAttachmentAsyncWithHttpInfo
     *
     * Get webhook test payload for new attachment event
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadNewAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTestWebhookPayloadNewAttachmentAsyncWithHttpInfo(string $contentType = self::contentTypes['getTestWebhookPayloadNewAttachment'][0])
    {
        $returnType = '\MailSlurp\Models\WebhookNewAttachmentPayload';
        $request = $this->getTestWebhookPayloadNewAttachmentRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTestWebhookPayloadNewAttachment'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadNewAttachment'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTestWebhookPayloadNewAttachmentRequest(string $contentType = self::contentTypes['getTestWebhookPayloadNewAttachment'][0])
    {


        $resourcePath = '/webhooks/test/new-attachment-payload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTestWebhookPayloadNewContact
     *
     * Get webhook test payload for new contact event
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadNewContact'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\WebhookNewContactPayload
     */
    public function getTestWebhookPayloadNewContact(string $contentType = self::contentTypes['getTestWebhookPayloadNewContact'][0])
    {
        list($response) = $this->getTestWebhookPayloadNewContactWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getTestWebhookPayloadNewContactWithHttpInfo
     *
     * Get webhook test payload for new contact event
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadNewContact'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\WebhookNewContactPayload, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTestWebhookPayloadNewContactWithHttpInfo(string $contentType = self::contentTypes['getTestWebhookPayloadNewContact'][0])
    {
        $request = $this->getTestWebhookPayloadNewContactRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\WebhookNewContactPayload' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\WebhookNewContactPayload' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\WebhookNewContactPayload', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\WebhookNewContactPayload';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\WebhookNewContactPayload',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTestWebhookPayloadNewContactAsync
     *
     * Get webhook test payload for new contact event
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadNewContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTestWebhookPayloadNewContactAsync(string $contentType = self::contentTypes['getTestWebhookPayloadNewContact'][0])
    {
        return $this->getTestWebhookPayloadNewContactAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTestWebhookPayloadNewContactAsyncWithHttpInfo
     *
     * Get webhook test payload for new contact event
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadNewContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTestWebhookPayloadNewContactAsyncWithHttpInfo(string $contentType = self::contentTypes['getTestWebhookPayloadNewContact'][0])
    {
        $returnType = '\MailSlurp\Models\WebhookNewContactPayload';
        $request = $this->getTestWebhookPayloadNewContactRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTestWebhookPayloadNewContact'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadNewContact'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTestWebhookPayloadNewContactRequest(string $contentType = self::contentTypes['getTestWebhookPayloadNewContact'][0])
    {


        $resourcePath = '/webhooks/test/new-contact-payload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTestWebhookPayloadNewEmail
     *
     * Get webhook test payload for new email event
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadNewEmail'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\WebhookNewEmailPayload
     */
    public function getTestWebhookPayloadNewEmail(string $contentType = self::contentTypes['getTestWebhookPayloadNewEmail'][0])
    {
        list($response) = $this->getTestWebhookPayloadNewEmailWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getTestWebhookPayloadNewEmailWithHttpInfo
     *
     * Get webhook test payload for new email event
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadNewEmail'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\WebhookNewEmailPayload, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTestWebhookPayloadNewEmailWithHttpInfo(string $contentType = self::contentTypes['getTestWebhookPayloadNewEmail'][0])
    {
        $request = $this->getTestWebhookPayloadNewEmailRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\WebhookNewEmailPayload' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\WebhookNewEmailPayload' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\WebhookNewEmailPayload', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\WebhookNewEmailPayload';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\WebhookNewEmailPayload',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTestWebhookPayloadNewEmailAsync
     *
     * Get webhook test payload for new email event
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadNewEmail'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTestWebhookPayloadNewEmailAsync(string $contentType = self::contentTypes['getTestWebhookPayloadNewEmail'][0])
    {
        return $this->getTestWebhookPayloadNewEmailAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTestWebhookPayloadNewEmailAsyncWithHttpInfo
     *
     * Get webhook test payload for new email event
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadNewEmail'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTestWebhookPayloadNewEmailAsyncWithHttpInfo(string $contentType = self::contentTypes['getTestWebhookPayloadNewEmail'][0])
    {
        $returnType = '\MailSlurp\Models\WebhookNewEmailPayload';
        $request = $this->getTestWebhookPayloadNewEmailRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTestWebhookPayloadNewEmail'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadNewEmail'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTestWebhookPayloadNewEmailRequest(string $contentType = self::contentTypes['getTestWebhookPayloadNewEmail'][0])
    {


        $resourcePath = '/webhooks/test/new-email-payload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTestWebhookPayloadNewSms
     *
     * Get webhook test payload for new sms event
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadNewSms'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\WebhookNewSmsPayload
     */
    public function getTestWebhookPayloadNewSms(string $contentType = self::contentTypes['getTestWebhookPayloadNewSms'][0])
    {
        list($response) = $this->getTestWebhookPayloadNewSmsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getTestWebhookPayloadNewSmsWithHttpInfo
     *
     * Get webhook test payload for new sms event
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadNewSms'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\WebhookNewSmsPayload, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTestWebhookPayloadNewSmsWithHttpInfo(string $contentType = self::contentTypes['getTestWebhookPayloadNewSms'][0])
    {
        $request = $this->getTestWebhookPayloadNewSmsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\WebhookNewSmsPayload' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\WebhookNewSmsPayload' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\WebhookNewSmsPayload', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\WebhookNewSmsPayload';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\WebhookNewSmsPayload',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTestWebhookPayloadNewSmsAsync
     *
     * Get webhook test payload for new sms event
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadNewSms'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTestWebhookPayloadNewSmsAsync(string $contentType = self::contentTypes['getTestWebhookPayloadNewSms'][0])
    {
        return $this->getTestWebhookPayloadNewSmsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTestWebhookPayloadNewSmsAsyncWithHttpInfo
     *
     * Get webhook test payload for new sms event
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadNewSms'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTestWebhookPayloadNewSmsAsyncWithHttpInfo(string $contentType = self::contentTypes['getTestWebhookPayloadNewSms'][0])
    {
        $returnType = '\MailSlurp\Models\WebhookNewSmsPayload';
        $request = $this->getTestWebhookPayloadNewSmsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTestWebhookPayloadNewSms'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getTestWebhookPayloadNewSms'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTestWebhookPayloadNewSmsRequest(string $contentType = self::contentTypes['getTestWebhookPayloadNewSms'][0])
    {


        $resourcePath = '/webhooks/test/new-sms-payload';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWebhook
     *
     * Get a webhook
     *
     * @param  string $webhook_id webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhook'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\WebhookDto
     */
    public function getWebhook($webhook_id, string $contentType = self::contentTypes['getWebhook'][0])
    {
        list($response) = $this->getWebhookWithHttpInfo($webhook_id, $contentType);
        return $response;
    }

    /**
     * Operation getWebhookWithHttpInfo
     *
     * Get a webhook
     *
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhook'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\WebhookDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWebhookWithHttpInfo($webhook_id, string $contentType = self::contentTypes['getWebhook'][0])
    {
        $request = $this->getWebhookRequest($webhook_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\WebhookDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\WebhookDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\WebhookDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\WebhookDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\WebhookDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWebhookAsync
     *
     * Get a webhook
     *
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebhookAsync($webhook_id, string $contentType = self::contentTypes['getWebhook'][0])
    {
        return $this->getWebhookAsyncWithHttpInfo($webhook_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWebhookAsyncWithHttpInfo
     *
     * Get a webhook
     *
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebhookAsyncWithHttpInfo($webhook_id, string $contentType = self::contentTypes['getWebhook'][0])
    {
        $returnType = '\MailSlurp\Models\WebhookDto';
        $request = $this->getWebhookRequest($webhook_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWebhook'
     *
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhook'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getWebhookRequest($webhook_id, string $contentType = self::contentTypes['getWebhook'][0])
    {

        // verify the required parameter 'webhook_id' is set
        if ($webhook_id === null || (is_array($webhook_id) && count($webhook_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_id when calling getWebhook'
            );
        }


        $resourcePath = '/webhooks/{webhookId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webhook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhookId' . '}',
                ObjectSerializer::toPathValue($webhook_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWebhookResult
     *
     * Get a webhook result for a webhook
     *
     * @param  string $webhook_result_id Webhook Result ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookResult'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\WebhookResultDto
     */
    public function getWebhookResult($webhook_result_id, string $contentType = self::contentTypes['getWebhookResult'][0])
    {
        list($response) = $this->getWebhookResultWithHttpInfo($webhook_result_id, $contentType);
        return $response;
    }

    /**
     * Operation getWebhookResultWithHttpInfo
     *
     * Get a webhook result for a webhook
     *
     * @param  string $webhook_result_id Webhook Result ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookResult'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\WebhookResultDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWebhookResultWithHttpInfo($webhook_result_id, string $contentType = self::contentTypes['getWebhookResult'][0])
    {
        $request = $this->getWebhookResultRequest($webhook_result_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\WebhookResultDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\WebhookResultDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\WebhookResultDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\WebhookResultDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\WebhookResultDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWebhookResultAsync
     *
     * Get a webhook result for a webhook
     *
     * @param  string $webhook_result_id Webhook Result ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookResult'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebhookResultAsync($webhook_result_id, string $contentType = self::contentTypes['getWebhookResult'][0])
    {
        return $this->getWebhookResultAsyncWithHttpInfo($webhook_result_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWebhookResultAsyncWithHttpInfo
     *
     * Get a webhook result for a webhook
     *
     * @param  string $webhook_result_id Webhook Result ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookResult'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebhookResultAsyncWithHttpInfo($webhook_result_id, string $contentType = self::contentTypes['getWebhookResult'][0])
    {
        $returnType = '\MailSlurp\Models\WebhookResultDto';
        $request = $this->getWebhookResultRequest($webhook_result_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWebhookResult'
     *
     * @param  string $webhook_result_id Webhook Result ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookResult'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getWebhookResultRequest($webhook_result_id, string $contentType = self::contentTypes['getWebhookResult'][0])
    {

        // verify the required parameter 'webhook_result_id' is set
        if ($webhook_result_id === null || (is_array($webhook_result_id) && count($webhook_result_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_result_id when calling getWebhookResult'
            );
        }


        $resourcePath = '/webhooks/results/{webhookResultId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webhook_result_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhookResultId' . '}',
                ObjectSerializer::toPathValue($webhook_result_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWebhookResults
     *
     * Get a webhook results for a webhook
     *
     * @param  string $webhook_id ID of webhook to get results for (required)
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size in list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  string $search_filter Optional search filter (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  bool $unseen_only Filter for unseen exceptions only (optional)
     * @param  string $result_type Filter by result type (optional)
     * @param  string $event_name Filter by event name (optional)
     * @param  int $min_status_code Minimum response status (optional)
     * @param  int $max_status_code Maximum response status (optional)
     * @param  string $inbox_id Inbox ID (optional)
     * @param  string $sms_id Sms ID (optional)
     * @param  string $attachment_id Attachment ID (optional)
     * @param  string $email_id Email ID (optional)
     * @param  string $phone_id Phone ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookResults'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\PageWebhookResult
     */
    public function getWebhookResults($webhook_id, $page = 0, $size = 20, $sort = 'ASC', $search_filter = null, $since = null, $before = null, $unseen_only = null, $result_type = null, $event_name = null, $min_status_code = null, $max_status_code = null, $inbox_id = null, $sms_id = null, $attachment_id = null, $email_id = null, $phone_id = null, string $contentType = self::contentTypes['getWebhookResults'][0])
    {
        list($response) = $this->getWebhookResultsWithHttpInfo($webhook_id, $page, $size, $sort, $search_filter, $since, $before, $unseen_only, $result_type, $event_name, $min_status_code, $max_status_code, $inbox_id, $sms_id, $attachment_id, $email_id, $phone_id, $contentType);
        return $response;
    }

    /**
     * Operation getWebhookResultsWithHttpInfo
     *
     * Get a webhook results for a webhook
     *
     * @param  string $webhook_id ID of webhook to get results for (required)
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size in list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  string $search_filter Optional search filter (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  bool $unseen_only Filter for unseen exceptions only (optional)
     * @param  string $result_type Filter by result type (optional)
     * @param  string $event_name Filter by event name (optional)
     * @param  int $min_status_code Minimum response status (optional)
     * @param  int $max_status_code Maximum response status (optional)
     * @param  string $inbox_id Inbox ID (optional)
     * @param  string $sms_id Sms ID (optional)
     * @param  string $attachment_id Attachment ID (optional)
     * @param  string $email_id Email ID (optional)
     * @param  string $phone_id Phone ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookResults'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\PageWebhookResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWebhookResultsWithHttpInfo($webhook_id, $page = 0, $size = 20, $sort = 'ASC', $search_filter = null, $since = null, $before = null, $unseen_only = null, $result_type = null, $event_name = null, $min_status_code = null, $max_status_code = null, $inbox_id = null, $sms_id = null, $attachment_id = null, $email_id = null, $phone_id = null, string $contentType = self::contentTypes['getWebhookResults'][0])
    {
        $request = $this->getWebhookResultsRequest($webhook_id, $page, $size, $sort, $search_filter, $since, $before, $unseen_only, $result_type, $event_name, $min_status_code, $max_status_code, $inbox_id, $sms_id, $attachment_id, $email_id, $phone_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\PageWebhookResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\PageWebhookResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\PageWebhookResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\PageWebhookResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\PageWebhookResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWebhookResultsAsync
     *
     * Get a webhook results for a webhook
     *
     * @param  string $webhook_id ID of webhook to get results for (required)
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size in list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  string $search_filter Optional search filter (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  bool $unseen_only Filter for unseen exceptions only (optional)
     * @param  string $result_type Filter by result type (optional)
     * @param  string $event_name Filter by event name (optional)
     * @param  int $min_status_code Minimum response status (optional)
     * @param  int $max_status_code Maximum response status (optional)
     * @param  string $inbox_id Inbox ID (optional)
     * @param  string $sms_id Sms ID (optional)
     * @param  string $attachment_id Attachment ID (optional)
     * @param  string $email_id Email ID (optional)
     * @param  string $phone_id Phone ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookResults'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebhookResultsAsync($webhook_id, $page = 0, $size = 20, $sort = 'ASC', $search_filter = null, $since = null, $before = null, $unseen_only = null, $result_type = null, $event_name = null, $min_status_code = null, $max_status_code = null, $inbox_id = null, $sms_id = null, $attachment_id = null, $email_id = null, $phone_id = null, string $contentType = self::contentTypes['getWebhookResults'][0])
    {
        return $this->getWebhookResultsAsyncWithHttpInfo($webhook_id, $page, $size, $sort, $search_filter, $since, $before, $unseen_only, $result_type, $event_name, $min_status_code, $max_status_code, $inbox_id, $sms_id, $attachment_id, $email_id, $phone_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWebhookResultsAsyncWithHttpInfo
     *
     * Get a webhook results for a webhook
     *
     * @param  string $webhook_id ID of webhook to get results for (required)
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size in list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  string $search_filter Optional search filter (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  bool $unseen_only Filter for unseen exceptions only (optional)
     * @param  string $result_type Filter by result type (optional)
     * @param  string $event_name Filter by event name (optional)
     * @param  int $min_status_code Minimum response status (optional)
     * @param  int $max_status_code Maximum response status (optional)
     * @param  string $inbox_id Inbox ID (optional)
     * @param  string $sms_id Sms ID (optional)
     * @param  string $attachment_id Attachment ID (optional)
     * @param  string $email_id Email ID (optional)
     * @param  string $phone_id Phone ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookResults'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebhookResultsAsyncWithHttpInfo($webhook_id, $page = 0, $size = 20, $sort = 'ASC', $search_filter = null, $since = null, $before = null, $unseen_only = null, $result_type = null, $event_name = null, $min_status_code = null, $max_status_code = null, $inbox_id = null, $sms_id = null, $attachment_id = null, $email_id = null, $phone_id = null, string $contentType = self::contentTypes['getWebhookResults'][0])
    {
        $returnType = '\MailSlurp\Models\PageWebhookResult';
        $request = $this->getWebhookResultsRequest($webhook_id, $page, $size, $sort, $search_filter, $since, $before, $unseen_only, $result_type, $event_name, $min_status_code, $max_status_code, $inbox_id, $sms_id, $attachment_id, $email_id, $phone_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWebhookResults'
     *
     * @param  string $webhook_id ID of webhook to get results for (required)
     * @param  int $page Optional page index in list pagination (optional, default to 0)
     * @param  int $size Optional page size in list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  string $search_filter Optional search filter (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  bool $unseen_only Filter for unseen exceptions only (optional)
     * @param  string $result_type Filter by result type (optional)
     * @param  string $event_name Filter by event name (optional)
     * @param  int $min_status_code Minimum response status (optional)
     * @param  int $max_status_code Maximum response status (optional)
     * @param  string $inbox_id Inbox ID (optional)
     * @param  string $sms_id Sms ID (optional)
     * @param  string $attachment_id Attachment ID (optional)
     * @param  string $email_id Email ID (optional)
     * @param  string $phone_id Phone ID (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookResults'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getWebhookResultsRequest($webhook_id, $page = 0, $size = 20, $sort = 'ASC', $search_filter = null, $since = null, $before = null, $unseen_only = null, $result_type = null, $event_name = null, $min_status_code = null, $max_status_code = null, $inbox_id = null, $sms_id = null, $attachment_id = null, $email_id = null, $phone_id = null, string $contentType = self::contentTypes['getWebhookResults'][0])
    {

        // verify the required parameter 'webhook_id' is set
        if ($webhook_id === null || (is_array($webhook_id) && count($webhook_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_id when calling getWebhookResults'
            );
        }


















        $resourcePath = '/webhooks/{webhookId}/results';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size,
            'size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_filter,
            'searchFilter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $since,
            'since', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $before,
            'before', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $unseen_only,
            'unseenOnly', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $result_type,
            'resultType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $event_name,
            'eventName', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_status_code,
            'minStatusCode', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_status_code,
            'maxStatusCode', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $inbox_id,
            'inboxId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sms_id,
            'smsId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $attachment_id,
            'attachmentId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email_id,
            'emailId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $phone_id,
            'phoneId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($webhook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhookId' . '}',
                ObjectSerializer::toPathValue($webhook_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWebhookResultsCount
     *
     * Get a webhook results count for a webhook
     *
     * @param  string $webhook_id ID of webhook to get results for (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookResultsCount'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\CountDto
     */
    public function getWebhookResultsCount($webhook_id, string $contentType = self::contentTypes['getWebhookResultsCount'][0])
    {
        list($response) = $this->getWebhookResultsCountWithHttpInfo($webhook_id, $contentType);
        return $response;
    }

    /**
     * Operation getWebhookResultsCountWithHttpInfo
     *
     * Get a webhook results count for a webhook
     *
     * @param  string $webhook_id ID of webhook to get results for (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookResultsCount'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\CountDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWebhookResultsCountWithHttpInfo($webhook_id, string $contentType = self::contentTypes['getWebhookResultsCount'][0])
    {
        $request = $this->getWebhookResultsCountRequest($webhook_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\CountDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\CountDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\CountDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\CountDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\CountDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWebhookResultsCountAsync
     *
     * Get a webhook results count for a webhook
     *
     * @param  string $webhook_id ID of webhook to get results for (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookResultsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebhookResultsCountAsync($webhook_id, string $contentType = self::contentTypes['getWebhookResultsCount'][0])
    {
        return $this->getWebhookResultsCountAsyncWithHttpInfo($webhook_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWebhookResultsCountAsyncWithHttpInfo
     *
     * Get a webhook results count for a webhook
     *
     * @param  string $webhook_id ID of webhook to get results for (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookResultsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebhookResultsCountAsyncWithHttpInfo($webhook_id, string $contentType = self::contentTypes['getWebhookResultsCount'][0])
    {
        $returnType = '\MailSlurp\Models\CountDto';
        $request = $this->getWebhookResultsCountRequest($webhook_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWebhookResultsCount'
     *
     * @param  string $webhook_id ID of webhook to get results for (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookResultsCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getWebhookResultsCountRequest($webhook_id, string $contentType = self::contentTypes['getWebhookResultsCount'][0])
    {

        // verify the required parameter 'webhook_id' is set
        if ($webhook_id === null || (is_array($webhook_id) && count($webhook_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_id when calling getWebhookResultsCount'
            );
        }


        $resourcePath = '/webhooks/{webhookId}/results/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webhook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhookId' . '}',
                ObjectSerializer::toPathValue($webhook_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWebhookResultsUnseenErrorCount
     *
     * Get count of unseen webhook results with error status
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookResultsUnseenErrorCount'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\UnseenErrorCountDto
     */
    public function getWebhookResultsUnseenErrorCount(string $contentType = self::contentTypes['getWebhookResultsUnseenErrorCount'][0])
    {
        list($response) = $this->getWebhookResultsUnseenErrorCountWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation getWebhookResultsUnseenErrorCountWithHttpInfo
     *
     * Get count of unseen webhook results with error status
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookResultsUnseenErrorCount'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\UnseenErrorCountDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getWebhookResultsUnseenErrorCountWithHttpInfo(string $contentType = self::contentTypes['getWebhookResultsUnseenErrorCount'][0])
    {
        $request = $this->getWebhookResultsUnseenErrorCountRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\UnseenErrorCountDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\UnseenErrorCountDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\UnseenErrorCountDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\UnseenErrorCountDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\UnseenErrorCountDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWebhookResultsUnseenErrorCountAsync
     *
     * Get count of unseen webhook results with error status
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookResultsUnseenErrorCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebhookResultsUnseenErrorCountAsync(string $contentType = self::contentTypes['getWebhookResultsUnseenErrorCount'][0])
    {
        return $this->getWebhookResultsUnseenErrorCountAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWebhookResultsUnseenErrorCountAsyncWithHttpInfo
     *
     * Get count of unseen webhook results with error status
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookResultsUnseenErrorCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getWebhookResultsUnseenErrorCountAsyncWithHttpInfo(string $contentType = self::contentTypes['getWebhookResultsUnseenErrorCount'][0])
    {
        $returnType = '\MailSlurp\Models\UnseenErrorCountDto';
        $request = $this->getWebhookResultsUnseenErrorCountRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWebhookResultsUnseenErrorCount'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhookResultsUnseenErrorCount'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getWebhookResultsUnseenErrorCountRequest(string $contentType = self::contentTypes['getWebhookResultsUnseenErrorCount'][0])
    {


        $resourcePath = '/webhooks/results/unseen-count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getWebhooks
     *
     * Get all webhooks for an Inbox
     *
     * @param  string $inbox_id inbox_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhooks'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\WebhookDto[]
     * @deprecated
     */
    public function getWebhooks($inbox_id, string $contentType = self::contentTypes['getWebhooks'][0])
    {
        list($response) = $this->getWebhooksWithHttpInfo($inbox_id, $contentType);
        return $response;
    }

    /**
     * Operation getWebhooksWithHttpInfo
     *
     * Get all webhooks for an Inbox
     *
     * @param  string $inbox_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhooks'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\WebhookDto[], HTTP status code, HTTP response headers (array of strings)
     * @deprecated
     */
    public function getWebhooksWithHttpInfo($inbox_id, string $contentType = self::contentTypes['getWebhooks'][0])
    {
        $request = $this->getWebhooksRequest($inbox_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\WebhookDto[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\WebhookDto[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\WebhookDto[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\WebhookDto[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\WebhookDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getWebhooksAsync
     *
     * Get all webhooks for an Inbox
     *
     * @param  string $inbox_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhooks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function getWebhooksAsync($inbox_id, string $contentType = self::contentTypes['getWebhooks'][0])
    {
        return $this->getWebhooksAsyncWithHttpInfo($inbox_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getWebhooksAsyncWithHttpInfo
     *
     * Get all webhooks for an Inbox
     *
     * @param  string $inbox_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhooks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     * @deprecated
     */
    public function getWebhooksAsyncWithHttpInfo($inbox_id, string $contentType = self::contentTypes['getWebhooks'][0])
    {
        $returnType = '\MailSlurp\Models\WebhookDto[]';
        $request = $this->getWebhooksRequest($inbox_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getWebhooks'
     *
     * @param  string $inbox_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getWebhooks'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     * @deprecated
     */
    public function getWebhooksRequest($inbox_id, string $contentType = self::contentTypes['getWebhooks'][0])
    {

        // verify the required parameter 'inbox_id' is set
        if ($inbox_id === null || (is_array($inbox_id) && count($inbox_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inbox_id when calling getWebhooks'
            );
        }


        $resourcePath = '/inboxes/{inboxId}/webhooks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($inbox_id !== null) {
            $resourcePath = str_replace(
                '{' . 'inboxId' . '}',
                ObjectSerializer::toPathValue($inbox_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation redriveAllWebhookResults
     *
     * Redrive all webhook results that have failed status
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redriveAllWebhookResults'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\WebhookRedriveAllResult
     */
    public function redriveAllWebhookResults(string $contentType = self::contentTypes['redriveAllWebhookResults'][0])
    {
        list($response) = $this->redriveAllWebhookResultsWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation redriveAllWebhookResultsWithHttpInfo
     *
     * Redrive all webhook results that have failed status
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redriveAllWebhookResults'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\WebhookRedriveAllResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function redriveAllWebhookResultsWithHttpInfo(string $contentType = self::contentTypes['redriveAllWebhookResults'][0])
    {
        $request = $this->redriveAllWebhookResultsRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\WebhookRedriveAllResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\WebhookRedriveAllResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\WebhookRedriveAllResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\WebhookRedriveAllResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\WebhookRedriveAllResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation redriveAllWebhookResultsAsync
     *
     * Redrive all webhook results that have failed status
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redriveAllWebhookResults'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function redriveAllWebhookResultsAsync(string $contentType = self::contentTypes['redriveAllWebhookResults'][0])
    {
        return $this->redriveAllWebhookResultsAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation redriveAllWebhookResultsAsyncWithHttpInfo
     *
     * Redrive all webhook results that have failed status
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redriveAllWebhookResults'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function redriveAllWebhookResultsAsyncWithHttpInfo(string $contentType = self::contentTypes['redriveAllWebhookResults'][0])
    {
        $returnType = '\MailSlurp\Models\WebhookRedriveAllResult';
        $request = $this->redriveAllWebhookResultsRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'redriveAllWebhookResults'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redriveAllWebhookResults'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function redriveAllWebhookResultsRequest(string $contentType = self::contentTypes['redriveAllWebhookResults'][0])
    {


        $resourcePath = '/webhooks/results/redrive';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation redriveWebhookResult
     *
     * Get a webhook result and try to resend the original webhook payload
     *
     * @param  string $webhook_result_id Webhook Result ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redriveWebhookResult'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\WebhookRedriveResult
     */
    public function redriveWebhookResult($webhook_result_id, string $contentType = self::contentTypes['redriveWebhookResult'][0])
    {
        list($response) = $this->redriveWebhookResultWithHttpInfo($webhook_result_id, $contentType);
        return $response;
    }

    /**
     * Operation redriveWebhookResultWithHttpInfo
     *
     * Get a webhook result and try to resend the original webhook payload
     *
     * @param  string $webhook_result_id Webhook Result ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redriveWebhookResult'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\WebhookRedriveResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function redriveWebhookResultWithHttpInfo($webhook_result_id, string $contentType = self::contentTypes['redriveWebhookResult'][0])
    {
        $request = $this->redriveWebhookResultRequest($webhook_result_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\WebhookRedriveResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\WebhookRedriveResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\WebhookRedriveResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\WebhookRedriveResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\WebhookRedriveResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation redriveWebhookResultAsync
     *
     * Get a webhook result and try to resend the original webhook payload
     *
     * @param  string $webhook_result_id Webhook Result ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redriveWebhookResult'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function redriveWebhookResultAsync($webhook_result_id, string $contentType = self::contentTypes['redriveWebhookResult'][0])
    {
        return $this->redriveWebhookResultAsyncWithHttpInfo($webhook_result_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation redriveWebhookResultAsyncWithHttpInfo
     *
     * Get a webhook result and try to resend the original webhook payload
     *
     * @param  string $webhook_result_id Webhook Result ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redriveWebhookResult'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function redriveWebhookResultAsyncWithHttpInfo($webhook_result_id, string $contentType = self::contentTypes['redriveWebhookResult'][0])
    {
        $returnType = '\MailSlurp\Models\WebhookRedriveResult';
        $request = $this->redriveWebhookResultRequest($webhook_result_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'redriveWebhookResult'
     *
     * @param  string $webhook_result_id Webhook Result ID (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['redriveWebhookResult'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function redriveWebhookResultRequest($webhook_result_id, string $contentType = self::contentTypes['redriveWebhookResult'][0])
    {

        // verify the required parameter 'webhook_result_id' is set
        if ($webhook_result_id === null || (is_array($webhook_result_id) && count($webhook_result_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_result_id when calling redriveWebhookResult'
            );
        }


        $resourcePath = '/webhooks/results/{webhookResultId}/redrive';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webhook_result_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhookResultId' . '}',
                ObjectSerializer::toPathValue($webhook_result_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendTestData
     *
     * Send webhook test data
     *
     * @param  string $webhook_id webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendTestData'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\WebhookTestResult
     */
    public function sendTestData($webhook_id, string $contentType = self::contentTypes['sendTestData'][0])
    {
        list($response) = $this->sendTestDataWithHttpInfo($webhook_id, $contentType);
        return $response;
    }

    /**
     * Operation sendTestDataWithHttpInfo
     *
     * Send webhook test data
     *
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendTestData'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\WebhookTestResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function sendTestDataWithHttpInfo($webhook_id, string $contentType = self::contentTypes['sendTestData'][0])
    {
        $request = $this->sendTestDataRequest($webhook_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\MailSlurp\Models\WebhookTestResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\WebhookTestResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\WebhookTestResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\WebhookTestResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\WebhookTestResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sendTestDataAsync
     *
     * Send webhook test data
     *
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendTestData'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendTestDataAsync($webhook_id, string $contentType = self::contentTypes['sendTestData'][0])
    {
        return $this->sendTestDataAsyncWithHttpInfo($webhook_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendTestDataAsyncWithHttpInfo
     *
     * Send webhook test data
     *
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendTestData'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendTestDataAsyncWithHttpInfo($webhook_id, string $contentType = self::contentTypes['sendTestData'][0])
    {
        $returnType = '\MailSlurp\Models\WebhookTestResult';
        $request = $this->sendTestDataRequest($webhook_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendTestData'
     *
     * @param  string $webhook_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['sendTestData'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function sendTestDataRequest($webhook_id, string $contentType = self::contentTypes['sendTestData'][0])
    {

        // verify the required parameter 'webhook_id' is set
        if ($webhook_id === null || (is_array($webhook_id) && count($webhook_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_id when calling sendTestData'
            );
        }


        $resourcePath = '/webhooks/{webhookId}/test';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webhook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhookId' . '}',
                ObjectSerializer::toPathValue($webhook_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateWebhookHeaders
     *
     * Update a webhook request headers
     *
     * @param  string $webhook_id webhook_id (required)
     * @param  \MailSlurp\Models\WebhookHeaders $webhook_headers webhook_headers (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhookHeaders'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\WebhookDto
     */
    public function updateWebhookHeaders($webhook_id, $webhook_headers, string $contentType = self::contentTypes['updateWebhookHeaders'][0])
    {
        list($response) = $this->updateWebhookHeadersWithHttpInfo($webhook_id, $webhook_headers, $contentType);
        return $response;
    }

    /**
     * Operation updateWebhookHeadersWithHttpInfo
     *
     * Update a webhook request headers
     *
     * @param  string $webhook_id (required)
     * @param  \MailSlurp\Models\WebhookHeaders $webhook_headers (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhookHeaders'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\WebhookDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateWebhookHeadersWithHttpInfo($webhook_id, $webhook_headers, string $contentType = self::contentTypes['updateWebhookHeaders'][0])
    {
        $request = $this->updateWebhookHeadersRequest($webhook_id, $webhook_headers, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\WebhookDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\WebhookDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\WebhookDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\WebhookDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\WebhookDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateWebhookHeadersAsync
     *
     * Update a webhook request headers
     *
     * @param  string $webhook_id (required)
     * @param  \MailSlurp\Models\WebhookHeaders $webhook_headers (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhookHeaders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateWebhookHeadersAsync($webhook_id, $webhook_headers, string $contentType = self::contentTypes['updateWebhookHeaders'][0])
    {
        return $this->updateWebhookHeadersAsyncWithHttpInfo($webhook_id, $webhook_headers, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateWebhookHeadersAsyncWithHttpInfo
     *
     * Update a webhook request headers
     *
     * @param  string $webhook_id (required)
     * @param  \MailSlurp\Models\WebhookHeaders $webhook_headers (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhookHeaders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateWebhookHeadersAsyncWithHttpInfo($webhook_id, $webhook_headers, string $contentType = self::contentTypes['updateWebhookHeaders'][0])
    {
        $returnType = '\MailSlurp\Models\WebhookDto';
        $request = $this->updateWebhookHeadersRequest($webhook_id, $webhook_headers, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateWebhookHeaders'
     *
     * @param  string $webhook_id (required)
     * @param  \MailSlurp\Models\WebhookHeaders $webhook_headers (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['updateWebhookHeaders'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateWebhookHeadersRequest($webhook_id, $webhook_headers, string $contentType = self::contentTypes['updateWebhookHeaders'][0])
    {

        // verify the required parameter 'webhook_id' is set
        if ($webhook_id === null || (is_array($webhook_id) && count($webhook_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_id when calling updateWebhookHeaders'
            );
        }

        // verify the required parameter 'webhook_headers' is set
        if ($webhook_headers === null || (is_array($webhook_headers) && count($webhook_headers) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_headers when calling updateWebhookHeaders'
            );
        }


        $resourcePath = '/webhooks/{webhookId}/headers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($webhook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhookId' . '}',
                ObjectSerializer::toPathValue($webhook_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($webhook_headers)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($webhook_headers));
            } else {
                $httpBody = $webhook_headers;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation verifyWebhookSignature
     *
     * Verify a webhook payload signature
     *
     * @param  \MailSlurp\Models\VerifyWebhookSignatureOptions $verify_webhook_signature_options verify_webhook_signature_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyWebhookSignature'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\VerifyWebhookSignatureResults
     */
    public function verifyWebhookSignature($verify_webhook_signature_options, string $contentType = self::contentTypes['verifyWebhookSignature'][0])
    {
        list($response) = $this->verifyWebhookSignatureWithHttpInfo($verify_webhook_signature_options, $contentType);
        return $response;
    }

    /**
     * Operation verifyWebhookSignatureWithHttpInfo
     *
     * Verify a webhook payload signature
     *
     * @param  \MailSlurp\Models\VerifyWebhookSignatureOptions $verify_webhook_signature_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyWebhookSignature'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\VerifyWebhookSignatureResults, HTTP status code, HTTP response headers (array of strings)
     */
    public function verifyWebhookSignatureWithHttpInfo($verify_webhook_signature_options, string $contentType = self::contentTypes['verifyWebhookSignature'][0])
    {
        $request = $this->verifyWebhookSignatureRequest($verify_webhook_signature_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\VerifyWebhookSignatureResults' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\VerifyWebhookSignatureResults' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\VerifyWebhookSignatureResults', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\VerifyWebhookSignatureResults';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\VerifyWebhookSignatureResults',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation verifyWebhookSignatureAsync
     *
     * Verify a webhook payload signature
     *
     * @param  \MailSlurp\Models\VerifyWebhookSignatureOptions $verify_webhook_signature_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyWebhookSignature'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function verifyWebhookSignatureAsync($verify_webhook_signature_options, string $contentType = self::contentTypes['verifyWebhookSignature'][0])
    {
        return $this->verifyWebhookSignatureAsyncWithHttpInfo($verify_webhook_signature_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation verifyWebhookSignatureAsyncWithHttpInfo
     *
     * Verify a webhook payload signature
     *
     * @param  \MailSlurp\Models\VerifyWebhookSignatureOptions $verify_webhook_signature_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyWebhookSignature'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function verifyWebhookSignatureAsyncWithHttpInfo($verify_webhook_signature_options, string $contentType = self::contentTypes['verifyWebhookSignature'][0])
    {
        $returnType = '\MailSlurp\Models\VerifyWebhookSignatureResults';
        $request = $this->verifyWebhookSignatureRequest($verify_webhook_signature_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'verifyWebhookSignature'
     *
     * @param  \MailSlurp\Models\VerifyWebhookSignatureOptions $verify_webhook_signature_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['verifyWebhookSignature'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function verifyWebhookSignatureRequest($verify_webhook_signature_options, string $contentType = self::contentTypes['verifyWebhookSignature'][0])
    {

        // verify the required parameter 'verify_webhook_signature_options' is set
        if ($verify_webhook_signature_options === null || (is_array($verify_webhook_signature_options) && count($verify_webhook_signature_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $verify_webhook_signature_options when calling verifyWebhookSignature'
            );
        }


        $resourcePath = '/webhooks/verify';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($verify_webhook_signature_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($verify_webhook_signature_options));
            } else {
                $httpBody = $verify_webhook_signature_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation waitForWebhookResults
     *
     * Wait for webhook results for a webhook
     *
     * @param  string $webhook_id ID of webhook to get results for (required)
     * @param  int $expected_count Expected result count (required)
     * @param  int $timeout Max time to wait in milliseconds (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['waitForWebhookResults'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\WebhookResultDto[]
     */
    public function waitForWebhookResults($webhook_id, $expected_count, $timeout, string $contentType = self::contentTypes['waitForWebhookResults'][0])
    {
        list($response) = $this->waitForWebhookResultsWithHttpInfo($webhook_id, $expected_count, $timeout, $contentType);
        return $response;
    }

    /**
     * Operation waitForWebhookResultsWithHttpInfo
     *
     * Wait for webhook results for a webhook
     *
     * @param  string $webhook_id ID of webhook to get results for (required)
     * @param  int $expected_count Expected result count (required)
     * @param  int $timeout Max time to wait in milliseconds (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['waitForWebhookResults'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\WebhookResultDto[], HTTP status code, HTTP response headers (array of strings)
     */
    public function waitForWebhookResultsWithHttpInfo($webhook_id, $expected_count, $timeout, string $contentType = self::contentTypes['waitForWebhookResults'][0])
    {
        $request = $this->waitForWebhookResultsRequest($webhook_id, $expected_count, $timeout, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\WebhookResultDto[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\WebhookResultDto[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\WebhookResultDto[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\WebhookResultDto[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\WebhookResultDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation waitForWebhookResultsAsync
     *
     * Wait for webhook results for a webhook
     *
     * @param  string $webhook_id ID of webhook to get results for (required)
     * @param  int $expected_count Expected result count (required)
     * @param  int $timeout Max time to wait in milliseconds (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['waitForWebhookResults'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function waitForWebhookResultsAsync($webhook_id, $expected_count, $timeout, string $contentType = self::contentTypes['waitForWebhookResults'][0])
    {
        return $this->waitForWebhookResultsAsyncWithHttpInfo($webhook_id, $expected_count, $timeout, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation waitForWebhookResultsAsyncWithHttpInfo
     *
     * Wait for webhook results for a webhook
     *
     * @param  string $webhook_id ID of webhook to get results for (required)
     * @param  int $expected_count Expected result count (required)
     * @param  int $timeout Max time to wait in milliseconds (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['waitForWebhookResults'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function waitForWebhookResultsAsyncWithHttpInfo($webhook_id, $expected_count, $timeout, string $contentType = self::contentTypes['waitForWebhookResults'][0])
    {
        $returnType = '\MailSlurp\Models\WebhookResultDto[]';
        $request = $this->waitForWebhookResultsRequest($webhook_id, $expected_count, $timeout, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'waitForWebhookResults'
     *
     * @param  string $webhook_id ID of webhook to get results for (required)
     * @param  int $expected_count Expected result count (required)
     * @param  int $timeout Max time to wait in milliseconds (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['waitForWebhookResults'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function waitForWebhookResultsRequest($webhook_id, $expected_count, $timeout, string $contentType = self::contentTypes['waitForWebhookResults'][0])
    {

        // verify the required parameter 'webhook_id' is set
        if ($webhook_id === null || (is_array($webhook_id) && count($webhook_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $webhook_id when calling waitForWebhookResults'
            );
        }

        // verify the required parameter 'expected_count' is set
        if ($expected_count === null || (is_array($expected_count) && count($expected_count) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $expected_count when calling waitForWebhookResults'
            );
        }
        if ($expected_count > 100) {
            throw new \InvalidArgumentException('invalid value for "$expected_count" when calling WebhookControllerApi.waitForWebhookResults, must be smaller than or equal to 100.');
        }
        
        // verify the required parameter 'timeout' is set
        if ($timeout === null || (is_array($timeout) && count($timeout) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $timeout when calling waitForWebhookResults'
            );
        }
        if ($timeout > 300000) {
            throw new \InvalidArgumentException('invalid value for "$timeout" when calling WebhookControllerApi.waitForWebhookResults, must be smaller than or equal to 300000.');
        }
        if ($timeout < 1000) {
            throw new \InvalidArgumentException('invalid value for "$timeout" when calling WebhookControllerApi.waitForWebhookResults, must be bigger than or equal to 1000.');
        }
        

        $resourcePath = '/webhooks/{webhookId}/wait';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expected_count,
            'expectedCount', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $timeout,
            'timeout', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($webhook_id !== null) {
            $resourcePath = str_replace(
                '{' . 'webhookId' . '}',
                ObjectSerializer::toPathValue($webhook_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
