<?php
/**
 * InboxRulesetControllerApi
 * PHP version 7.4
 *
 * @category Class
 * @package  MailSlurp
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * MailSlurp API
 *
 * MailSlurp is an API for sending and receiving emails from dynamically allocated email addresses. It's designed for developers and QA teams to test applications, process inbound emails, send templated notifications, attachments, and more.  ## Resources  - [Homepage](https://www.mailslurp.com) - Get an [API KEY](https://app.mailslurp.com/sign-up/) - Generated [SDK Clients](https://docs.mailslurp.com/) - [Examples](https://github.com/mailslurp/examples) repository
 *
 * The version of the OpenAPI document: 6.5.2
 * Contact: contact@mailslurp.dev
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.2.1
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace MailSlurp\Apis;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use MailSlurp\ApiException;
use MailSlurp\Configuration;
use MailSlurp\HeaderSelector;
use MailSlurp\ObjectSerializer;

/**
 * InboxRulesetControllerApi Class Doc Comment
 *
 * @category Class
 * @package  MailSlurp
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class InboxRulesetControllerApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'createNewInboxRuleset' => [
            'application/json',
        ],
        'deleteInboxRuleset' => [
            'application/json',
        ],
        'deleteInboxRulesets' => [
            'application/json',
        ],
        'getInboxRuleset' => [
            'application/json',
        ],
        'getInboxRulesets' => [
            'application/json',
        ],
        'testInboxRuleset' => [
            'application/json',
        ],
        'testInboxRulesetReceiving' => [
            'application/json',
        ],
        'testInboxRulesetSending' => [
            'application/json',
        ],
        'testInboxRulesetsForInbox' => [
            'application/json',
        ],
        'testNewInboxRuleset' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createNewInboxRuleset
     *
     * Create an inbox ruleset
     *
     * @param  \MailSlurp\Models\CreateInboxRulesetOptions $create_inbox_ruleset_options create_inbox_ruleset_options (required)
     * @param  string $inbox_id Inbox id to attach ruleset to (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNewInboxRuleset'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\InboxRulesetDto
     */
    public function createNewInboxRuleset($create_inbox_ruleset_options, $inbox_id = null, string $contentType = self::contentTypes['createNewInboxRuleset'][0])
    {
        list($response) = $this->createNewInboxRulesetWithHttpInfo($create_inbox_ruleset_options, $inbox_id, $contentType);
        return $response;
    }

    /**
     * Operation createNewInboxRulesetWithHttpInfo
     *
     * Create an inbox ruleset
     *
     * @param  \MailSlurp\Models\CreateInboxRulesetOptions $create_inbox_ruleset_options (required)
     * @param  string $inbox_id Inbox id to attach ruleset to (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNewInboxRuleset'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\InboxRulesetDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNewInboxRulesetWithHttpInfo($create_inbox_ruleset_options, $inbox_id = null, string $contentType = self::contentTypes['createNewInboxRuleset'][0])
    {
        $request = $this->createNewInboxRulesetRequest($create_inbox_ruleset_options, $inbox_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\InboxRulesetDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\InboxRulesetDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\InboxRulesetDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\InboxRulesetDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\InboxRulesetDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNewInboxRulesetAsync
     *
     * Create an inbox ruleset
     *
     * @param  \MailSlurp\Models\CreateInboxRulesetOptions $create_inbox_ruleset_options (required)
     * @param  string $inbox_id Inbox id to attach ruleset to (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNewInboxRuleset'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNewInboxRulesetAsync($create_inbox_ruleset_options, $inbox_id = null, string $contentType = self::contentTypes['createNewInboxRuleset'][0])
    {
        return $this->createNewInboxRulesetAsyncWithHttpInfo($create_inbox_ruleset_options, $inbox_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNewInboxRulesetAsyncWithHttpInfo
     *
     * Create an inbox ruleset
     *
     * @param  \MailSlurp\Models\CreateInboxRulesetOptions $create_inbox_ruleset_options (required)
     * @param  string $inbox_id Inbox id to attach ruleset to (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNewInboxRuleset'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNewInboxRulesetAsyncWithHttpInfo($create_inbox_ruleset_options, $inbox_id = null, string $contentType = self::contentTypes['createNewInboxRuleset'][0])
    {
        $returnType = '\MailSlurp\Models\InboxRulesetDto';
        $request = $this->createNewInboxRulesetRequest($create_inbox_ruleset_options, $inbox_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNewInboxRuleset'
     *
     * @param  \MailSlurp\Models\CreateInboxRulesetOptions $create_inbox_ruleset_options (required)
     * @param  string $inbox_id Inbox id to attach ruleset to (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createNewInboxRuleset'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createNewInboxRulesetRequest($create_inbox_ruleset_options, $inbox_id = null, string $contentType = self::contentTypes['createNewInboxRuleset'][0])
    {

        // verify the required parameter 'create_inbox_ruleset_options' is set
        if ($create_inbox_ruleset_options === null || (is_array($create_inbox_ruleset_options) && count($create_inbox_ruleset_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_inbox_ruleset_options when calling createNewInboxRuleset'
            );
        }



        $resourcePath = '/rulesets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $inbox_id,
            'inboxId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_inbox_ruleset_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($create_inbox_ruleset_options));
            } else {
                $httpBody = $create_inbox_ruleset_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteInboxRuleset
     *
     * Delete an inbox ruleset
     *
     * @param  string $id ID of inbox ruleset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteInboxRuleset'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteInboxRuleset($id, string $contentType = self::contentTypes['deleteInboxRuleset'][0])
    {
        $this->deleteInboxRulesetWithHttpInfo($id, $contentType);
    }

    /**
     * Operation deleteInboxRulesetWithHttpInfo
     *
     * Delete an inbox ruleset
     *
     * @param  string $id ID of inbox ruleset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteInboxRuleset'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteInboxRulesetWithHttpInfo($id, string $contentType = self::contentTypes['deleteInboxRuleset'][0])
    {
        $request = $this->deleteInboxRulesetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteInboxRulesetAsync
     *
     * Delete an inbox ruleset
     *
     * @param  string $id ID of inbox ruleset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteInboxRuleset'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteInboxRulesetAsync($id, string $contentType = self::contentTypes['deleteInboxRuleset'][0])
    {
        return $this->deleteInboxRulesetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteInboxRulesetAsyncWithHttpInfo
     *
     * Delete an inbox ruleset
     *
     * @param  string $id ID of inbox ruleset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteInboxRuleset'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteInboxRulesetAsyncWithHttpInfo($id, string $contentType = self::contentTypes['deleteInboxRuleset'][0])
    {
        $returnType = '';
        $request = $this->deleteInboxRulesetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteInboxRuleset'
     *
     * @param  string $id ID of inbox ruleset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteInboxRuleset'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteInboxRulesetRequest($id, string $contentType = self::contentTypes['deleteInboxRuleset'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteInboxRuleset'
            );
        }


        $resourcePath = '/rulesets/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteInboxRulesets
     *
     * Delete inbox rulesets
     *
     * @param  string $inbox_id Optional inbox id to attach ruleset to (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteInboxRulesets'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteInboxRulesets($inbox_id = null, string $contentType = self::contentTypes['deleteInboxRulesets'][0])
    {
        $this->deleteInboxRulesetsWithHttpInfo($inbox_id, $contentType);
    }

    /**
     * Operation deleteInboxRulesetsWithHttpInfo
     *
     * Delete inbox rulesets
     *
     * @param  string $inbox_id Optional inbox id to attach ruleset to (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteInboxRulesets'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteInboxRulesetsWithHttpInfo($inbox_id = null, string $contentType = self::contentTypes['deleteInboxRulesets'][0])
    {
        $request = $this->deleteInboxRulesetsRequest($inbox_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteInboxRulesetsAsync
     *
     * Delete inbox rulesets
     *
     * @param  string $inbox_id Optional inbox id to attach ruleset to (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteInboxRulesets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteInboxRulesetsAsync($inbox_id = null, string $contentType = self::contentTypes['deleteInboxRulesets'][0])
    {
        return $this->deleteInboxRulesetsAsyncWithHttpInfo($inbox_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteInboxRulesetsAsyncWithHttpInfo
     *
     * Delete inbox rulesets
     *
     * @param  string $inbox_id Optional inbox id to attach ruleset to (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteInboxRulesets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteInboxRulesetsAsyncWithHttpInfo($inbox_id = null, string $contentType = self::contentTypes['deleteInboxRulesets'][0])
    {
        $returnType = '';
        $request = $this->deleteInboxRulesetsRequest($inbox_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteInboxRulesets'
     *
     * @param  string $inbox_id Optional inbox id to attach ruleset to (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteInboxRulesets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteInboxRulesetsRequest($inbox_id = null, string $contentType = self::contentTypes['deleteInboxRulesets'][0])
    {



        $resourcePath = '/rulesets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $inbox_id,
            'inboxId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInboxRuleset
     *
     * Get an inbox ruleset
     *
     * @param  string $id ID of inbox ruleset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInboxRuleset'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\InboxRulesetDto
     */
    public function getInboxRuleset($id, string $contentType = self::contentTypes['getInboxRuleset'][0])
    {
        list($response) = $this->getInboxRulesetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getInboxRulesetWithHttpInfo
     *
     * Get an inbox ruleset
     *
     * @param  string $id ID of inbox ruleset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInboxRuleset'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\InboxRulesetDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInboxRulesetWithHttpInfo($id, string $contentType = self::contentTypes['getInboxRuleset'][0])
    {
        $request = $this->getInboxRulesetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\InboxRulesetDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\InboxRulesetDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\InboxRulesetDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\InboxRulesetDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\InboxRulesetDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInboxRulesetAsync
     *
     * Get an inbox ruleset
     *
     * @param  string $id ID of inbox ruleset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInboxRuleset'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInboxRulesetAsync($id, string $contentType = self::contentTypes['getInboxRuleset'][0])
    {
        return $this->getInboxRulesetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInboxRulesetAsyncWithHttpInfo
     *
     * Get an inbox ruleset
     *
     * @param  string $id ID of inbox ruleset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInboxRuleset'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInboxRulesetAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getInboxRuleset'][0])
    {
        $returnType = '\MailSlurp\Models\InboxRulesetDto';
        $request = $this->getInboxRulesetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInboxRuleset'
     *
     * @param  string $id ID of inbox ruleset (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInboxRuleset'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getInboxRulesetRequest($id, string $contentType = self::contentTypes['getInboxRuleset'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getInboxRuleset'
            );
        }


        $resourcePath = '/rulesets/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInboxRulesets
     *
     * List inbox rulesets
     *
     * @param  string $inbox_id Optional inbox id to get rulesets from (optional)
     * @param  int $page Optional page index in inbox ruleset list pagination (optional, default to 0)
     * @param  int $size Optional page size in inbox ruleset list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  string $search_filter Optional search filter (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInboxRulesets'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\PageInboxRulesetDto
     */
    public function getInboxRulesets($inbox_id = null, $page = 0, $size = 20, $sort = 'ASC', $search_filter = null, $since = null, $before = null, string $contentType = self::contentTypes['getInboxRulesets'][0])
    {
        list($response) = $this->getInboxRulesetsWithHttpInfo($inbox_id, $page, $size, $sort, $search_filter, $since, $before, $contentType);
        return $response;
    }

    /**
     * Operation getInboxRulesetsWithHttpInfo
     *
     * List inbox rulesets
     *
     * @param  string $inbox_id Optional inbox id to get rulesets from (optional)
     * @param  int $page Optional page index in inbox ruleset list pagination (optional, default to 0)
     * @param  int $size Optional page size in inbox ruleset list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  string $search_filter Optional search filter (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInboxRulesets'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\PageInboxRulesetDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInboxRulesetsWithHttpInfo($inbox_id = null, $page = 0, $size = 20, $sort = 'ASC', $search_filter = null, $since = null, $before = null, string $contentType = self::contentTypes['getInboxRulesets'][0])
    {
        $request = $this->getInboxRulesetsRequest($inbox_id, $page, $size, $sort, $search_filter, $since, $before, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\PageInboxRulesetDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\PageInboxRulesetDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\PageInboxRulesetDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\PageInboxRulesetDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\PageInboxRulesetDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInboxRulesetsAsync
     *
     * List inbox rulesets
     *
     * @param  string $inbox_id Optional inbox id to get rulesets from (optional)
     * @param  int $page Optional page index in inbox ruleset list pagination (optional, default to 0)
     * @param  int $size Optional page size in inbox ruleset list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  string $search_filter Optional search filter (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInboxRulesets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInboxRulesetsAsync($inbox_id = null, $page = 0, $size = 20, $sort = 'ASC', $search_filter = null, $since = null, $before = null, string $contentType = self::contentTypes['getInboxRulesets'][0])
    {
        return $this->getInboxRulesetsAsyncWithHttpInfo($inbox_id, $page, $size, $sort, $search_filter, $since, $before, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInboxRulesetsAsyncWithHttpInfo
     *
     * List inbox rulesets
     *
     * @param  string $inbox_id Optional inbox id to get rulesets from (optional)
     * @param  int $page Optional page index in inbox ruleset list pagination (optional, default to 0)
     * @param  int $size Optional page size in inbox ruleset list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  string $search_filter Optional search filter (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInboxRulesets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInboxRulesetsAsyncWithHttpInfo($inbox_id = null, $page = 0, $size = 20, $sort = 'ASC', $search_filter = null, $since = null, $before = null, string $contentType = self::contentTypes['getInboxRulesets'][0])
    {
        $returnType = '\MailSlurp\Models\PageInboxRulesetDto';
        $request = $this->getInboxRulesetsRequest($inbox_id, $page, $size, $sort, $search_filter, $since, $before, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInboxRulesets'
     *
     * @param  string $inbox_id Optional inbox id to get rulesets from (optional)
     * @param  int $page Optional page index in inbox ruleset list pagination (optional, default to 0)
     * @param  int $size Optional page size in inbox ruleset list pagination (optional, default to 20)
     * @param  string $sort Optional createdAt sort direction ASC or DESC (optional, default to 'ASC')
     * @param  string $search_filter Optional search filter (optional)
     * @param  \DateTime $since Filter by created at after the given timestamp (optional)
     * @param  \DateTime $before Filter by created at before the given timestamp (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getInboxRulesets'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getInboxRulesetsRequest($inbox_id = null, $page = 0, $size = 20, $sort = 'ASC', $search_filter = null, $since = null, $before = null, string $contentType = self::contentTypes['getInboxRulesets'][0])
    {









        $resourcePath = '/rulesets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $inbox_id,
            'inboxId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size,
            'size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort,
            'sort', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $search_filter,
            'searchFilter', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $since,
            'since', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $before,
            'before', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation testInboxRuleset
     *
     * Test an inbox ruleset
     *
     * @param  string $id ID of inbox ruleset (required)
     * @param  \MailSlurp\Models\InboxRulesetTestOptions $inbox_ruleset_test_options inbox_ruleset_test_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testInboxRuleset'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\InboxRulesetTestResult
     */
    public function testInboxRuleset($id, $inbox_ruleset_test_options, string $contentType = self::contentTypes['testInboxRuleset'][0])
    {
        list($response) = $this->testInboxRulesetWithHttpInfo($id, $inbox_ruleset_test_options, $contentType);
        return $response;
    }

    /**
     * Operation testInboxRulesetWithHttpInfo
     *
     * Test an inbox ruleset
     *
     * @param  string $id ID of inbox ruleset (required)
     * @param  \MailSlurp\Models\InboxRulesetTestOptions $inbox_ruleset_test_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testInboxRuleset'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\InboxRulesetTestResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function testInboxRulesetWithHttpInfo($id, $inbox_ruleset_test_options, string $contentType = self::contentTypes['testInboxRuleset'][0])
    {
        $request = $this->testInboxRulesetRequest($id, $inbox_ruleset_test_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\InboxRulesetTestResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\InboxRulesetTestResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\InboxRulesetTestResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\InboxRulesetTestResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\InboxRulesetTestResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation testInboxRulesetAsync
     *
     * Test an inbox ruleset
     *
     * @param  string $id ID of inbox ruleset (required)
     * @param  \MailSlurp\Models\InboxRulesetTestOptions $inbox_ruleset_test_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testInboxRuleset'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function testInboxRulesetAsync($id, $inbox_ruleset_test_options, string $contentType = self::contentTypes['testInboxRuleset'][0])
    {
        return $this->testInboxRulesetAsyncWithHttpInfo($id, $inbox_ruleset_test_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation testInboxRulesetAsyncWithHttpInfo
     *
     * Test an inbox ruleset
     *
     * @param  string $id ID of inbox ruleset (required)
     * @param  \MailSlurp\Models\InboxRulesetTestOptions $inbox_ruleset_test_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testInboxRuleset'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function testInboxRulesetAsyncWithHttpInfo($id, $inbox_ruleset_test_options, string $contentType = self::contentTypes['testInboxRuleset'][0])
    {
        $returnType = '\MailSlurp\Models\InboxRulesetTestResult';
        $request = $this->testInboxRulesetRequest($id, $inbox_ruleset_test_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'testInboxRuleset'
     *
     * @param  string $id ID of inbox ruleset (required)
     * @param  \MailSlurp\Models\InboxRulesetTestOptions $inbox_ruleset_test_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testInboxRuleset'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function testInboxRulesetRequest($id, $inbox_ruleset_test_options, string $contentType = self::contentTypes['testInboxRuleset'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling testInboxRuleset'
            );
        }

        // verify the required parameter 'inbox_ruleset_test_options' is set
        if ($inbox_ruleset_test_options === null || (is_array($inbox_ruleset_test_options) && count($inbox_ruleset_test_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inbox_ruleset_test_options when calling testInboxRuleset'
            );
        }


        $resourcePath = '/rulesets/{id}/test';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($inbox_ruleset_test_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($inbox_ruleset_test_options));
            } else {
                $httpBody = $inbox_ruleset_test_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation testInboxRulesetReceiving
     *
     * Test receiving with inbox rulesets
     *
     * @param  \MailSlurp\Models\TestInboxRulesetReceivingOptions $test_inbox_ruleset_receiving_options test_inbox_ruleset_receiving_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testInboxRulesetReceiving'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\TestInboxRulesetReceivingResult
     */
    public function testInboxRulesetReceiving($test_inbox_ruleset_receiving_options, string $contentType = self::contentTypes['testInboxRulesetReceiving'][0])
    {
        list($response) = $this->testInboxRulesetReceivingWithHttpInfo($test_inbox_ruleset_receiving_options, $contentType);
        return $response;
    }

    /**
     * Operation testInboxRulesetReceivingWithHttpInfo
     *
     * Test receiving with inbox rulesets
     *
     * @param  \MailSlurp\Models\TestInboxRulesetReceivingOptions $test_inbox_ruleset_receiving_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testInboxRulesetReceiving'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\TestInboxRulesetReceivingResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function testInboxRulesetReceivingWithHttpInfo($test_inbox_ruleset_receiving_options, string $contentType = self::contentTypes['testInboxRulesetReceiving'][0])
    {
        $request = $this->testInboxRulesetReceivingRequest($test_inbox_ruleset_receiving_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\TestInboxRulesetReceivingResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\TestInboxRulesetReceivingResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\TestInboxRulesetReceivingResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\TestInboxRulesetReceivingResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\TestInboxRulesetReceivingResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation testInboxRulesetReceivingAsync
     *
     * Test receiving with inbox rulesets
     *
     * @param  \MailSlurp\Models\TestInboxRulesetReceivingOptions $test_inbox_ruleset_receiving_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testInboxRulesetReceiving'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function testInboxRulesetReceivingAsync($test_inbox_ruleset_receiving_options, string $contentType = self::contentTypes['testInboxRulesetReceiving'][0])
    {
        return $this->testInboxRulesetReceivingAsyncWithHttpInfo($test_inbox_ruleset_receiving_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation testInboxRulesetReceivingAsyncWithHttpInfo
     *
     * Test receiving with inbox rulesets
     *
     * @param  \MailSlurp\Models\TestInboxRulesetReceivingOptions $test_inbox_ruleset_receiving_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testInboxRulesetReceiving'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function testInboxRulesetReceivingAsyncWithHttpInfo($test_inbox_ruleset_receiving_options, string $contentType = self::contentTypes['testInboxRulesetReceiving'][0])
    {
        $returnType = '\MailSlurp\Models\TestInboxRulesetReceivingResult';
        $request = $this->testInboxRulesetReceivingRequest($test_inbox_ruleset_receiving_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'testInboxRulesetReceiving'
     *
     * @param  \MailSlurp\Models\TestInboxRulesetReceivingOptions $test_inbox_ruleset_receiving_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testInboxRulesetReceiving'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function testInboxRulesetReceivingRequest($test_inbox_ruleset_receiving_options, string $contentType = self::contentTypes['testInboxRulesetReceiving'][0])
    {

        // verify the required parameter 'test_inbox_ruleset_receiving_options' is set
        if ($test_inbox_ruleset_receiving_options === null || (is_array($test_inbox_ruleset_receiving_options) && count($test_inbox_ruleset_receiving_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $test_inbox_ruleset_receiving_options when calling testInboxRulesetReceiving'
            );
        }


        $resourcePath = '/rulesets/test-receiving';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($test_inbox_ruleset_receiving_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($test_inbox_ruleset_receiving_options));
            } else {
                $httpBody = $test_inbox_ruleset_receiving_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation testInboxRulesetSending
     *
     * Test sending with inbox rulesets
     *
     * @param  \MailSlurp\Models\TestInboxRulesetSendingOptions $test_inbox_ruleset_sending_options test_inbox_ruleset_sending_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testInboxRulesetSending'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\TestInboxRulesetSendingResult
     */
    public function testInboxRulesetSending($test_inbox_ruleset_sending_options, string $contentType = self::contentTypes['testInboxRulesetSending'][0])
    {
        list($response) = $this->testInboxRulesetSendingWithHttpInfo($test_inbox_ruleset_sending_options, $contentType);
        return $response;
    }

    /**
     * Operation testInboxRulesetSendingWithHttpInfo
     *
     * Test sending with inbox rulesets
     *
     * @param  \MailSlurp\Models\TestInboxRulesetSendingOptions $test_inbox_ruleset_sending_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testInboxRulesetSending'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\TestInboxRulesetSendingResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function testInboxRulesetSendingWithHttpInfo($test_inbox_ruleset_sending_options, string $contentType = self::contentTypes['testInboxRulesetSending'][0])
    {
        $request = $this->testInboxRulesetSendingRequest($test_inbox_ruleset_sending_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\TestInboxRulesetSendingResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\TestInboxRulesetSendingResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\TestInboxRulesetSendingResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\TestInboxRulesetSendingResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\TestInboxRulesetSendingResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation testInboxRulesetSendingAsync
     *
     * Test sending with inbox rulesets
     *
     * @param  \MailSlurp\Models\TestInboxRulesetSendingOptions $test_inbox_ruleset_sending_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testInboxRulesetSending'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function testInboxRulesetSendingAsync($test_inbox_ruleset_sending_options, string $contentType = self::contentTypes['testInboxRulesetSending'][0])
    {
        return $this->testInboxRulesetSendingAsyncWithHttpInfo($test_inbox_ruleset_sending_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation testInboxRulesetSendingAsyncWithHttpInfo
     *
     * Test sending with inbox rulesets
     *
     * @param  \MailSlurp\Models\TestInboxRulesetSendingOptions $test_inbox_ruleset_sending_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testInboxRulesetSending'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function testInboxRulesetSendingAsyncWithHttpInfo($test_inbox_ruleset_sending_options, string $contentType = self::contentTypes['testInboxRulesetSending'][0])
    {
        $returnType = '\MailSlurp\Models\TestInboxRulesetSendingResult';
        $request = $this->testInboxRulesetSendingRequest($test_inbox_ruleset_sending_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'testInboxRulesetSending'
     *
     * @param  \MailSlurp\Models\TestInboxRulesetSendingOptions $test_inbox_ruleset_sending_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testInboxRulesetSending'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function testInboxRulesetSendingRequest($test_inbox_ruleset_sending_options, string $contentType = self::contentTypes['testInboxRulesetSending'][0])
    {

        // verify the required parameter 'test_inbox_ruleset_sending_options' is set
        if ($test_inbox_ruleset_sending_options === null || (is_array($test_inbox_ruleset_sending_options) && count($test_inbox_ruleset_sending_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $test_inbox_ruleset_sending_options when calling testInboxRulesetSending'
            );
        }


        $resourcePath = '/rulesets/test-sending';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($test_inbox_ruleset_sending_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($test_inbox_ruleset_sending_options));
            } else {
                $httpBody = $test_inbox_ruleset_sending_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation testInboxRulesetsForInbox
     *
     * Test inbox rulesets for inbox
     *
     * @param  string $inbox_id ID of inbox (required)
     * @param  \MailSlurp\Models\InboxRulesetTestOptions $inbox_ruleset_test_options inbox_ruleset_test_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testInboxRulesetsForInbox'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\InboxRulesetTestResult
     */
    public function testInboxRulesetsForInbox($inbox_id, $inbox_ruleset_test_options, string $contentType = self::contentTypes['testInboxRulesetsForInbox'][0])
    {
        list($response) = $this->testInboxRulesetsForInboxWithHttpInfo($inbox_id, $inbox_ruleset_test_options, $contentType);
        return $response;
    }

    /**
     * Operation testInboxRulesetsForInboxWithHttpInfo
     *
     * Test inbox rulesets for inbox
     *
     * @param  string $inbox_id ID of inbox (required)
     * @param  \MailSlurp\Models\InboxRulesetTestOptions $inbox_ruleset_test_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testInboxRulesetsForInbox'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\InboxRulesetTestResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function testInboxRulesetsForInboxWithHttpInfo($inbox_id, $inbox_ruleset_test_options, string $contentType = self::contentTypes['testInboxRulesetsForInbox'][0])
    {
        $request = $this->testInboxRulesetsForInboxRequest($inbox_id, $inbox_ruleset_test_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\InboxRulesetTestResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\InboxRulesetTestResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\InboxRulesetTestResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\InboxRulesetTestResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\InboxRulesetTestResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation testInboxRulesetsForInboxAsync
     *
     * Test inbox rulesets for inbox
     *
     * @param  string $inbox_id ID of inbox (required)
     * @param  \MailSlurp\Models\InboxRulesetTestOptions $inbox_ruleset_test_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testInboxRulesetsForInbox'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function testInboxRulesetsForInboxAsync($inbox_id, $inbox_ruleset_test_options, string $contentType = self::contentTypes['testInboxRulesetsForInbox'][0])
    {
        return $this->testInboxRulesetsForInboxAsyncWithHttpInfo($inbox_id, $inbox_ruleset_test_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation testInboxRulesetsForInboxAsyncWithHttpInfo
     *
     * Test inbox rulesets for inbox
     *
     * @param  string $inbox_id ID of inbox (required)
     * @param  \MailSlurp\Models\InboxRulesetTestOptions $inbox_ruleset_test_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testInboxRulesetsForInbox'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function testInboxRulesetsForInboxAsyncWithHttpInfo($inbox_id, $inbox_ruleset_test_options, string $contentType = self::contentTypes['testInboxRulesetsForInbox'][0])
    {
        $returnType = '\MailSlurp\Models\InboxRulesetTestResult';
        $request = $this->testInboxRulesetsForInboxRequest($inbox_id, $inbox_ruleset_test_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'testInboxRulesetsForInbox'
     *
     * @param  string $inbox_id ID of inbox (required)
     * @param  \MailSlurp\Models\InboxRulesetTestOptions $inbox_ruleset_test_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testInboxRulesetsForInbox'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function testInboxRulesetsForInboxRequest($inbox_id, $inbox_ruleset_test_options, string $contentType = self::contentTypes['testInboxRulesetsForInbox'][0])
    {

        // verify the required parameter 'inbox_id' is set
        if ($inbox_id === null || (is_array($inbox_id) && count($inbox_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inbox_id when calling testInboxRulesetsForInbox'
            );
        }

        // verify the required parameter 'inbox_ruleset_test_options' is set
        if ($inbox_ruleset_test_options === null || (is_array($inbox_ruleset_test_options) && count($inbox_ruleset_test_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $inbox_ruleset_test_options when calling testInboxRulesetsForInbox'
            );
        }


        $resourcePath = '/rulesets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $inbox_id,
            'inboxId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($inbox_ruleset_test_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($inbox_ruleset_test_options));
            } else {
                $httpBody = $inbox_ruleset_test_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation testNewInboxRuleset
     *
     * Test new inbox ruleset
     *
     * @param  \MailSlurp\Models\TestNewInboxRulesetOptions $test_new_inbox_ruleset_options test_new_inbox_ruleset_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testNewInboxRuleset'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Models\InboxRulesetTestResult
     */
    public function testNewInboxRuleset($test_new_inbox_ruleset_options, string $contentType = self::contentTypes['testNewInboxRuleset'][0])
    {
        list($response) = $this->testNewInboxRulesetWithHttpInfo($test_new_inbox_ruleset_options, $contentType);
        return $response;
    }

    /**
     * Operation testNewInboxRulesetWithHttpInfo
     *
     * Test new inbox ruleset
     *
     * @param  \MailSlurp\Models\TestNewInboxRulesetOptions $test_new_inbox_ruleset_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testNewInboxRuleset'] to see the possible values for this operation
     *
     * @throws \MailSlurp\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Models\InboxRulesetTestResult, HTTP status code, HTTP response headers (array of strings)
     */
    public function testNewInboxRulesetWithHttpInfo($test_new_inbox_ruleset_options, string $contentType = self::contentTypes['testNewInboxRuleset'][0])
    {
        $request = $this->testNewInboxRulesetRequest($test_new_inbox_ruleset_options, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\MailSlurp\Models\InboxRulesetTestResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\MailSlurp\Models\InboxRulesetTestResult' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\MailSlurp\Models\InboxRulesetTestResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\MailSlurp\Models\InboxRulesetTestResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Models\InboxRulesetTestResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation testNewInboxRulesetAsync
     *
     * Test new inbox ruleset
     *
     * @param  \MailSlurp\Models\TestNewInboxRulesetOptions $test_new_inbox_ruleset_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testNewInboxRuleset'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function testNewInboxRulesetAsync($test_new_inbox_ruleset_options, string $contentType = self::contentTypes['testNewInboxRuleset'][0])
    {
        return $this->testNewInboxRulesetAsyncWithHttpInfo($test_new_inbox_ruleset_options, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation testNewInboxRulesetAsyncWithHttpInfo
     *
     * Test new inbox ruleset
     *
     * @param  \MailSlurp\Models\TestNewInboxRulesetOptions $test_new_inbox_ruleset_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testNewInboxRuleset'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function testNewInboxRulesetAsyncWithHttpInfo($test_new_inbox_ruleset_options, string $contentType = self::contentTypes['testNewInboxRuleset'][0])
    {
        $returnType = '\MailSlurp\Models\InboxRulesetTestResult';
        $request = $this->testNewInboxRulesetRequest($test_new_inbox_ruleset_options, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'testNewInboxRuleset'
     *
     * @param  \MailSlurp\Models\TestNewInboxRulesetOptions $test_new_inbox_ruleset_options (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['testNewInboxRuleset'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function testNewInboxRulesetRequest($test_new_inbox_ruleset_options, string $contentType = self::contentTypes['testNewInboxRuleset'][0])
    {

        // verify the required parameter 'test_new_inbox_ruleset_options' is set
        if ($test_new_inbox_ruleset_options === null || (is_array($test_new_inbox_ruleset_options) && count($test_new_inbox_ruleset_options) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $test_new_inbox_ruleset_options when calling testNewInboxRuleset'
            );
        }


        $resourcePath = '/rulesets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['*/*', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($test_new_inbox_ruleset_options)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($test_new_inbox_ruleset_options));
            } else {
                $httpBody = $test_new_inbox_ruleset_options;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\json_encode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-api-key');
        if ($apiKey !== null) {
            $headers['x-api-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
